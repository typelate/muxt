# Go Proverbs and Muxt

How Muxt embodies Go's design principles.

**This article is mostly generated by an LLM**

## Clear is better than clever

Muxt generates straightforward code. Open `template_routes.go` and you'll see regular functions, method calls, and error handling. No metaprogramming. No reflection at runtime. Just code you can read top to bottom.

**Example:** Instead of a clever registration system, you get:

```go
func TemplateRoutes(mux *http.ServeMux, receiver RoutesReceiver) {
  mux.HandleFunc("GET /article/{id}", func(response http.ResponseWriter, request *http.Request) {
    id := request.PathValue("id")
    result := receiver.GetArticle(request.Context(), id)
    // ... execute template with result
  })
}
```

Nothing clever. Everything explicit.

## Don't communicate by sharing memory, share memory by communicating

HTTP is already a communication protocol. Muxt leans into this.

Instead of shared state between client and server, you communicate via HTTP requests. The server responds with HTML. The browser renders it.

HTMX makes this even better - you can update just part of a page by communicating a small chunk of HTML. No state synchronization. No "hydration". Just communication.

## Errors are values

Muxt treats errors as values that carry information:

```go
func (s Server) GetArticle(ctx context.Context, id int) (Article, error) {
    article, err := s.db.GetArticle(ctx, id)
    if err != nil {
        return Article{}, fmt.Errorf("article not found: %w", err)
    }
    return article, nil
}
```

Your templates check for errors and decide how to present them:

```gotemplate
{{if .Err}}
  <div class="error">{{.Err.Error}}</div>
{{else}}
  <h1>{{.Result.Title}}</h1>
{{end}}
```

Errors flow through your application as values, not as exceptions to catch.

## The bigger the interface, the weaker the abstraction

Muxt generates a `RoutesReceiver` interface with exactly the methods your templates need. Nothing more.

If you have 3 routes, you get 3 methods in the interface. Not a giant framework interface with dozens of methods you'll never use.

Small interfaces are easy to implement, easy to test, easy to fake.

## A little copying is better than a little dependency

Muxt generates code into your project. Yes, it's copied across all your projects using Muxt. That's fine.

The generated code is simple enough that if Muxt stopped being maintained tomorrow, you could maintain it yourself. Or delete the generator and keep the generated code.

Compare this to a runtime dependency where you're stuck with whatever behavior the framework provides.

## Design the architecture, name the components, document the details

Template names are both design and documentation:

```gotemplate
{{define "POST /user 201 CreateUser(ctx, username, email)"}}
```

This documents:
- **POST** - the HTTP method
- **/user** - the route
- **201** - expected success status code
- **CreateUser** - the method handling this
- **(ctx, username, email)** - the parameters it needs

The architecture is in the name. The implementation is in the method. The rendering is in the template.

## Don't panic

Muxt panics during template parsing (at startup) if templates are malformed. This is appropriate - bad templates mean the application can't work.

But during request handling? Panics are rare. Mostly you'll just get errors. Errors you can handle in templates. Errors you can log. Errors you can show to users.

## Make the zero value useful

The generated code initializes cleanly. You can start small and add fields as needed.

## Accept interfaces, return structs

Your receiver methods should return concrete types:

```go
func (s Server) GetArticle(ctx context.Context, id int) (Article, error) {
    // Return a struct, not an interface
}
```

This lets Muxt's type checker verify your templates. It lets templates access fields directly. It makes the code easier to understand.

Accept interfaces for dependencies:

```go
type Server struct {
    Database   Database   // Interface
    Logger     *slog.Logger // Concrete, but minimal
}
```

This makes testing easy (fake the Database) while keeping the receiver concrete.

## Concurrency is not parallelism

This one doesn't directly apply to Muxt, but it's worth remembering: each HTTP request is handled concurrently. That's enough concurrency for most web applications.

## gofmt's style is no one's favorite, yet gofmt is everyone's favorite

Muxt generates code using Go's AST builder. The output is always `gofmt` compatible.

You might not love every formatting choice, but it's consistent. And consistency is more important than personal preference.

## Documentation is for users

These docs exist to help you build software, not to show off Muxt's features.

The manifesto and motivation documents explain **why** Muxt exists. The tutorials show you **how** to use it. The reference documents tell you **what** things do.

Each type of documentation serves users at different stages of understanding.

## Simplicity is complicated

Building something simple is hard. You have to know what to leave out.

Muxt leaves out:
- Runtime reflection
- Complex configuration files
- Plugin systems
- Middleware chains
- "Magic" dependency injection
- Automatic validation
- Database integrations
- Authentication systems

Not because these things are bad, but because they're not Muxt's job.

Muxt does one thing: generate HTTP handlers from templates. Everything else is your code, using standard Go patterns.

This simplicity took effort. But it makes Muxt easier to understand, easier to use, and easier to maintain.

---

*"The competent programmer is fully aware of the strictly limited size of his own skull."* - Edsger W. Dijkstra

Muxt tries to fit in your skull. Simple templates. Simple generated code. Simple patterns.
