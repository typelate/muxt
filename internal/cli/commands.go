package cli

import (
	"bytes"
	_ "embed"
	"flag"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"
	"time"

	"github.com/typelate/muxt/internal/muxt"
)

func Commands(wd string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	if len(args) <= 1 {
		return writeHelp(stdout)
	}
	args = args[1:]
	var err error
	wd, args, err = global(wd, args, stderr)
	if err != nil {
		return err
	}
	switch cmd, cmdArgs := args[0], args[1:]; cmd {
	case "help":
		return writeHelp(stdout)
	case "generate", "gen", "g":
		return generateCommand(wd, cmdArgs, getEnv, stdout, stderr)
	case "version", "v":
		return versionCommand(stdout)
	case "check", "c", "typelate":
		return checkCommand(wd, cmdArgs, stderr)
	case "documentation", "docs", "d":
		return documentationCommand(wd, cmdArgs, stdout, stderr)
	default:
		return fmt.Errorf("unknown command")
	}
}

func checkCommand(workingDirectory string, args []string, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if err := muxt.Check(workingDirectory, log.New(stderr, "", 0), config); err != nil {
		return fmt.Errorf("fail: %s", err)
	}
	return nil
}

const (
	codeGenerationComment = `// Code generated by muxt. DO NOT EDIT.` + "\n"
	codeGenerationLicense = `// MIT License
//
// Copyright (c) %d %s
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
`
)

func generateCommand(workingDirectory string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if v, ok := cliVersion(); ok {
		config.MuxtVersion = v
	}
	s, err := muxt.TemplateRoutesFile(workingDirectory, log.New(stdout, "", 0), config)
	if err != nil {
		return err
	}
	var sb bytes.Buffer
	writeCodeGenerationComment(&sb)
	sb.WriteString(s)
	return os.WriteFile(filepath.Join(workingDirectory, config.OutputFileName), sb.Bytes(), 0o644)
}

func writeCodeGenerationComment(w io.StringWriter) {
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationComment))
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n//\n")
	}
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationLicense, time.Now().Year(), "Christopher Hunter"))
}

//go:embed help.txt
var helpText string

func writeHelp(stdout io.Writer) error {
	var help strings.Builder
	help.WriteString(helpText)
	flagSet := routesFileConfigurationFlagSet(new(muxt.RoutesFileConfiguration))
	flagSet.SetOutput(&help)
	flagSet.PrintDefaults()
	_, err := fmt.Fprint(stdout, help.String())
	return err
}

func documentationCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	return muxt.Documentation(stdout, wd, config)
}

func versionCommand(stdout io.Writer) error {
	v, ok := cliVersion()
	if !ok {
		return fmt.Errorf("missing CLI version")
	}
	_, err := fmt.Fprintln(stdout, v)
	return err
}

func cliVersion() (string, bool) {
	bi, ok := debug.ReadBuildInfo()
	if !ok || bi.Main.Version == "" {
		return "", false
	}
	return bi.Main.Version, true
}

func global(wd string, args []string, stdout io.Writer) (string, []string, error) {
	var changeDir string
	flagSet := flag.NewFlagSet("muxt global", flag.ExitOnError)
	flagSet.SetOutput(stdout)
	flagSet.StringVar(&changeDir, "C", "", "change root directory")
	if err := flagSet.Parse(args); err != nil {
		return "", nil, err
	}
	if filepath.IsAbs(changeDir) {
		return changeDir, flagSet.Args(), nil
	}
	cd, err := filepath.Abs(filepath.Join(wd, changeDir))
	if err != nil {
		return "", nil, err
	}
	return cd, flagSet.Args(), nil
}

const (
	outputFlagNameHelp = `The generated file name containing the routes function and receiver interface.`
	outputFlagName     = "output-file"

	templatesVariableHelp = `the name of the global variable with type *"html/template".Template in the working directory package.`
	templatesVariable     = "templates-variable"

	templateDataType     = "template-data-type"
	templateDataTypeHelp = `The type name for the template data passed to root route templates.`

	routesFuncHelp = `The function name for the package registering handler functions on an *"net/http".ServeMux.
This function also receives an argument with a type matching the name given by receiver-interface.`
	routesFunc = "routes-func"

	receiverStaticTypeHelp = `The type name for a named type to use for looking up method signatures. If not set, all methods added to the receiver interface will have inferred signatures with argument types based on the argument identifier names. The inferred method signatures always return a single result of type any.`
	receiverStaticType     = "receiver-type"

	receiverStaticTypePackageHelp = `The package path to use when looking for receiver-type. If not set, the package in the current directory is used.`
	receiverStaticTypePackage     = "receiver-type-package"

	receiverInterfaceNameHelp = `The interface name in the generated output-file listing the methods used by the handler routes in routes-func.`
	receiverInterfaceName     = "receiver-interface"

	templateRoutePathsType     = "template-route-paths-type"
	templateRoutePathsTypeHelp = `The type name for the type with path constructor helper methods.`

	errIdentSuffix = " value must be a well-formed Go identifier"
)

func newRoutesFileConfiguration(args []string, stderr io.Writer) (muxt.RoutesFileConfiguration, error) {
	var g muxt.RoutesFileConfiguration
	flagSet := routesFileConfigurationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(templatesVariable + errIdentSuffix)
	}
	if g.RoutesFunction != "" && !token.IsIdentifier(g.RoutesFunction) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(routesFunc + errIdentSuffix)
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(receiverStaticType + errIdentSuffix)
	}
	if g.ReceiverInterface != "" && !token.IsIdentifier(g.ReceiverInterface) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(receiverInterfaceName + errIdentSuffix)
	}
	if g.TemplateDataType != "" && !token.IsIdentifier(g.TemplateDataType) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(templateDataType + errIdentSuffix)
	}
	if g.TemplateRoutePathsTypeName != "" && !token.IsIdentifier(g.TemplateRoutePathsTypeName) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(templateRoutePathsType + errIdentSuffix)
	}
	if g.OutputFileName != "" && filepath.Ext(g.OutputFileName) != ".go" {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func routesFileConfigurationFlagSet(g *muxt.RoutesFileConfiguration) *flag.FlagSet {
	flagSet := flag.NewFlagSet("generate", flag.ContinueOnError)
	flagSet.StringVar(&g.OutputFileName, outputFlagName, muxt.DefaultOutputFileName, outputFlagNameHelp)
	flagSet.StringVar(&g.TemplatesVariable, templatesVariable, muxt.DefaultTemplatesVariableName, templatesVariableHelp)
	flagSet.StringVar(&g.RoutesFunction, routesFunc, muxt.DefaultRoutesFunctionName, routesFuncHelp)
	flagSet.StringVar(&g.ReceiverType, receiverStaticType, "", receiverStaticTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, receiverStaticTypePackage, "", receiverStaticTypePackageHelp)
	flagSet.StringVar(&g.ReceiverInterface, receiverInterfaceName, muxt.DefaultReceiverInterfaceName, receiverInterfaceNameHelp)
	flagSet.StringVar(&g.TemplateDataType, templateDataType, muxt.DefaultTemplateDataTypeName, templateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, templateRoutePathsType, muxt.DefaultTemplateRoutePathsTypeName, templateRoutePathsTypeHelp)
	return flagSet
}
