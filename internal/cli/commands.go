package cli

import (
	"bytes"
	"cmp"
	_ "embed"
	"errors"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"

	"github.com/spf13/pflag"

	"github.com/typelate/muxt/internal/analysis"
	"github.com/typelate/muxt/internal/asteval"
	"github.com/typelate/muxt/internal/generate"
)

const (
	helpCommandName                = "help"
	generateCommandName            = "generate"
	versionCommandName             = "version"
	checkCommandName               = "check"
	readTemplateSourceCommandName  = "read-template-source"
	listTemplateCallersCommandName = "list-template-callers"
	listTemplateCallsCommandName   = "list-template-calls"
)

func Commands(wd string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	args = args[1:]
	var err error
	wd, args, err = global(wd, args, stderr)
	if err != nil {
		return err
	}
	if len(args) == 0 {
		return listRoutes(wd, nil, stdout, stderr)
	}
	switch cmd, cmdArgs := args[0], args[1:]; cmd {
	case helpCommandName, "h":
		return writeHelp(stdout, nil)
	case generateCommandName, "gen", "g":
		return generateCommand(wd, cmdArgs, getEnv, stdout, stderr)
	case versionCommandName, "v":
		return versionCommand(cmdArgs, stdout, stderr)
	case checkCommandName, "c":
		return checkCommand(wd, cmdArgs, stderr)
	//case readTemplateSourceCommandName, "source":
	//	return templateSourceCommand(wd, args[1:], stdout, stderr)
	case listTemplateCallersCommandName, "callers":
		return listTemplateCallersCommand(wd, args[1:], stdout, stderr)
	case listTemplateCallsCommandName, "calls":
		return listTemplateCallsCommand(wd, args[1:], stdout, stderr)
	default:
		return writeHelp(stderr, fmt.Errorf("unknown command: %q", cmd))
	}
}

func checkCommand(workingDirectory string, args []string, stderr io.Writer) error {
	config, err := newCheckConfiguration(args, stderr)
	if err != nil {
		return err
	}
	fileSet, pl, err := asteval.LoadPackages(workingDirectory)
	if err != nil {
		return err
	}
	logger := log.New(stderr, "", 0)
	if err := analysis.Check(config, workingDirectory, logger, fileSet, pl); err != nil {
		return fmt.Errorf("fail: %s", err)
	}
	return nil
}

const (
	codeGenerationComment = `// Code generated by muxt generate %s. DO NOT EDIT.` + "\n"
)

func generateCommand(workingDirectory string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if v, ok := cliVersion(); ok {
		config.MuxtVersion = v
	}
	applyDefaults(&config)
	fileSet, pl, err := asteval.LoadPackages(workingDirectory, config.ReceiverPackage)
	if err != nil {
		return err
	}
	files, err := generate.TemplateRoutesFile(workingDirectory, config, fileSet, pl, log.New(stdout, "", 0))
	if err != nil {
		return err
	}

	// CLEANUP HEURISTIC:
	// We automatically delete muxt-generated files that are no longer needed to avoid
	// manual cleanup when template files are renamed or generation modes change.
	//
	// Files are identified by:
	// 1. Presence of "// Code generated by muxt generate" comment
	// 2. Matching --output-routes-func value (to differentiate multiple route sets)
	//
	// Cleanup scenarios:
	// - Template renamed: old_template_routes_gen.go deleted when template renamed to new.gohtml
	// - Switch to single-file: all per-file *_template_routes_gen.go files deleted
	// - Switch to multi-file: old single template_routes.go overwritten (if same filename)
	// - Routes function unchanged: only deletes files matching current routes function
	//
	// IMPORTANT: If you change --output-routes-func value, old files with the previous
	// routes function name will NOT be deleted (to allow multiple route sets to coexist).
	// To clean up after changing routes function name, manually delete old files or
	// temporarily use the old --output-routes-func value with current templates.

	// Find existing generated files for cleanup
	oldGeneratedFiles, err := findGeneratedFiles(workingDirectory, config.RoutesFunction)
	if err != nil {
		return err
	}

	// Write new files
	newGeneratedFiles := make(map[string]bool)
	for i, file := range files {
		var sb bytes.Buffer
		writeCodeGenerationComment(&sb, configToArgs(config))
		sb.WriteString(file.Content)
		if err := os.WriteFile(file.Path, sb.Bytes(), 0o644); err != nil {
			for _, f := range files[:i] {
				if rmErr := os.Remove(f.Path); rmErr != nil {
					err = errors.Join(err, rmErr)
				}
			}
			return err
		}
		newGeneratedFiles[file.Path] = true
	}

	// Clean up orphaned files
	// Only deletes files that match the current routes function name but weren't regenerated
	for oldFile := range oldGeneratedFiles {
		if !newGeneratedFiles[oldFile] {
			if err := os.Remove(oldFile); err != nil && !os.IsNotExist(err) {
				return fmt.Errorf("failed to remove orphaned file %s: %w", oldFile, err)
			}
		}
	}

	return nil
}

// findGeneratedFiles scans the working directory for muxt-generated Go files
// that match the specified routes function name.
//
// Files are identified by:
// 1. Having a "// Code generated by muxt generate" comment on the first line
// 2. Matching the routes function name extracted from the generation comment
//
// This allows multiple muxt invocations with different --output-routes-func values
// to coexist in the same package without interfering with each other.
//
// Returns a map of absolute file paths that were generated with the same routes function.
func findGeneratedFiles(workingDirectory, routesFunction string) (map[string]bool, error) {
	generatedFiles := make(map[string]bool)

	entries, err := os.ReadDir(workingDirectory)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".go") {
			continue
		}

		filePath := filepath.Join(workingDirectory, entry.Name())
		content, err := os.ReadFile(filePath)
		if err != nil {
			return nil, fmt.Errorf("failed to read %s: %w", filePath, err)
		}

		// Check if file has muxt generation comment
		lines := strings.Split(string(content), "\n")
		if len(lines) == 0 {
			continue
		}

		firstLine := lines[0]
		if !strings.HasPrefix(firstLine, "// Code generated by muxt generate") {
			continue
		}

		// Parse the routes function name from the generation comment
		// Only include files that match the current routes function name
		generatedRoutesFunc := parseRoutesFunctionFromComment(firstLine)
		if generatedRoutesFunc == "" {
			log.Println("WARNING: ignored generated file with empty TemplateRoutes identifier", filePath)
			continue
		}
		if generatedRoutesFunc == routesFunction {
			generatedFiles[filePath] = true
		}
	}

	return generatedFiles, nil
}

func parseRoutesFunctionFromComment(comment string) string {
	// Extract args from: // Code generated by muxt generate [args]. DO NOT EDIT.
	prefix := "// Code generated by muxt generate "
	suffix := ". DO NOT EDIT."

	if !strings.HasPrefix(comment, prefix) {
		return ""
	}
	if !strings.HasSuffix(comment, suffix) {
		return ""
	}

	args := strings.TrimSuffix(strings.TrimPrefix(comment, prefix), suffix)

	// Parse flags to find --output-routes-func=value (normalized format)
	parts := strings.Fields(args)
	for _, part := range parts {
		if strings.HasPrefix(part, "--output-routes-func=") {
			return strings.TrimPrefix(part, "--output-routes-func=")
		}
		// Also check deprecated flag
		if strings.HasPrefix(part, "--routes-func=") {
			return strings.TrimPrefix(part, "--routes-func=")
		}
	}

	// If no flag specified, return default
	return defaultRoutesFunctionName
}

func configToArgs(config generate.RoutesFileConfiguration) []string {
	var args []string

	// Add non-default string flags
	if config.TemplatesVariable != defaultTemplatesVariableName {
		args = append(args, "--"+useTemplatesVariable+"="+config.TemplatesVariable)
	}
	if config.ReceiverType != "" {
		args = append(args, "--"+useReceiverType+"="+config.ReceiverType)
	}
	if config.ReceiverPackage != "" {
		args = append(args, "--"+useReceiverTypePackage+"="+config.ReceiverPackage)
	}
	if config.OutputFileName != defaultOutputFileName {
		args = append(args, "--"+outputFile+"="+config.OutputFileName)
	}
	if config.ReceiverInterface != defaultReceiverInterfaceName {
		args = append(args, "--"+outputReceiverInterface+"="+config.ReceiverInterface)
	}
	if config.RoutesFunction != defaultRoutesFunctionName {
		args = append(args, "--"+outputRoutesFunc+"="+config.RoutesFunction)
	}
	if config.TemplateDataType != defaultTemplateDataTypeName {
		args = append(args, "--"+outputTemplateDataType+"="+config.TemplateDataType)
	}
	if config.TemplateRoutePathsTypeName != defaultTemplateRoutePathsTypeName {
		args = append(args, "--"+outputTemplateRoutePathsType+"="+config.TemplateRoutePathsTypeName)
	}

	// Add boolean flags if true
	if config.Logger {
		args = append(args, "--"+outputRoutesFuncWithLoggerParam)
	}
	if config.PathPrefix {
		args = append(args, "--"+outputRoutesFuncWithPathPrefix)
	}
	if config.OutputMultipleFiles {
		args = append(args, "--"+outputMultipleFiles)
	}

	return args
}

func writeCodeGenerationComment(w io.StringWriter, args []string) {
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationComment, strings.TrimSpace(strings.Join(args, " "))))
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n\n")
	}
}

//go:embed help.txt
var helpText string

func writeHelp(stderr io.Writer, err error) error {
	var b strings.Builder
	if err != nil {
		b.WriteString("ERROR: ")
		b.WriteString(err.Error())
		b.WriteString("\n\n")
	}
	b.WriteString(helpText)
	flagSet := routesFileConfigurationFlagSet(new(generate.RoutesFileConfiguration))
	flagSet.SetOutput(&b)
	flagSet.PrintDefaults()
	_, err = fmt.Fprint(stderr, b.String())
	return err
}

func templateSourceCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newTemplateSourceConfiguration(args, stderr)
	if err != nil {
		return err
	}
	_, pl, err := asteval.LoadPackages(wd)
	if err != nil {
		return err
	}
	routesPkg, ok := asteval.PackageAtFilepath(pl, wd)
	if !ok {
		return fmt.Errorf("package not found at %s", wd)
	}

	ts, _, err := asteval.Templates(wd, config.TemplatesVariable, routesPkg)
	if err != nil {
		return err
	}
	return analysis.NewTemplateSource(config, stdout, ts)
}

func listTemplateCallersCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newListTemplateCallersConfiguration(args, stderr)
	if err != nil {
		return err
	}
	fileSet, pl, err := asteval.LoadPackages(wd)
	if err != nil {
		return err
	}
	pkg, glb, ts, err := asteval.LoadTemplates(wd, config.TemplatesVariable, pl)
	if err != nil {
		return err
	}
	return analysis.NewTemplateCallers(config, stdout, fileSet, pkg, glb, ts)
}

func listTemplateCallsCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newListTemplateCallsConfiguration(args, stderr)
	if err != nil {
		return err
	}
	_, pl, err := asteval.LoadPackages(wd)
	if err != nil {
		return err
	}
	pkg, glb, ts, err := asteval.LoadTemplates(wd, config.TemplatesVariable, pl)
	if err != nil {
		return err
	}
	return analysis.NewTemplateCalls(config, stdout, pkg, glb, ts)
}

func listRoutes(wd string, args []string, stdout, stderr io.Writer) error {
	// Default behavior (current implementation)
	config, err := newListRoutesConfiguration(args, stderr)
	if err != nil {
		return err
	}
	fileSet, pl, err := asteval.LoadPackages(wd, config.ReceiverPackage)
	if err != nil {
		return err
	}
	return analysis.NewRoutes(config, stdout, wd, fileSet, pl)
}

func versionCommand(args []string, stdout, stderr io.Writer) error {
	var verbose bool
	flagSet := pflag.NewFlagSet("version", pflag.ContinueOnError)
	flagSet.SetOutput(stderr)
	flagSet.BoolVarP(&verbose, "verbose", "v", false, "verbose output")
	if err := flagSet.Parse(args); err != nil {
		return err
	}

	v, ok := cliVersion()
	if !ok {
		return fmt.Errorf("missing CLI version")
	}
	if _, err := fmt.Fprintln(stdout, v); err != nil {
		return err
	}

	if verbose {
		bi, ok := debug.ReadBuildInfo()
		if ok {
			if _, err := fmt.Fprintf(stdout, "go version: %s\n", bi.GoVersion); err != nil {
				return err
			}
		}
	}

	return nil
}

func cliVersion() (string, bool) {
	bi, ok := debug.ReadBuildInfo()
	if !ok || bi.Main.Version == "" {
		return "", false
	}
	return bi.Main.Version, true
}

func global(wd string, args []string, stdout io.Writer) (string, []string, error) {
	var changeDir string
	flagSet := pflag.NewFlagSet("muxt global", pflag.ExitOnError)
	flagSet.SetOutput(stdout)
	flagSet.SetInterspersed(false)
	flagSet.StringVarP(&changeDir, "C", "C", "", "change root directory")
	if err := flagSet.Parse(args); err != nil {
		return "", nil, err
	}
	if filepath.IsAbs(changeDir) {
		return changeDir, flagSet.Args(), nil
	}
	cd, err := filepath.Abs(filepath.Join(wd, changeDir))
	if err != nil {
		return "", nil, err
	}
	return cd, flagSet.Args(), nil
}

const (
	// New flag names with clear prefixes
	useTemplatesVariable            = "use-templates-variable"
	useReceiverType                 = "use-receiver-type"
	useReceiverTypePackage          = "use-receiver-type-package"
	outputFile                      = "output-file"
	outputReceiverInterface         = "output-receiver-interface"
	outputRoutesFunc                = "output-routes-func"
	outputTemplateDataType          = "output-template-data-type"
	outputTemplateRoutePathsType    = "output-template-route-paths-type"
	outputRoutesFuncWithLoggerParam = "output-routes-func-with-logger-param"
	outputRoutesFuncWithPathPrefix  = "output-routes-func-with-path-prefix-param"
	outputMultipleFiles             = "output-multiple-files"

	// Deprecated feature flag names
	deprecatedPathPrefix = "path-prefix"
	deprecatedLogger     = "logger"

	// Deprecated flag names (for backward compatibility)
	deprecatedTemplatesVariable       = "templates-variable"
	deprecatedReceiverType            = "receiver-type"
	deprecatedReceiverTypePackage     = "receiver-type-package"
	deprecatedReceiverInterface       = "receiver-interface"
	deprecatedRoutesFunc              = "routes-func"
	deprecatedTemplateDataType        = "template-data-type"
	deprecatedTemplateRoutePathsType  = "template-route-paths-type"
	deprecatedFindTemplatesVariable   = "find-templates-variable"
	deprecatedFindReceiverType        = "find-receiver-type"
	deprecatedFindReceiverTypePackage = "find-receiver-type-package"

	// Help text
	useTemplatesVariableHelp   = `the name of the global variable with type *"html/template".Template in the working directory package.`
	useReceiverTypeHelp        = `The type name for a named type to use for looking up method signatures. If not set, all methods added to the receiver interface will have inferred signatures with argument types based on the argument identifier names. The inferred method signatures always return a single result of type any.`
	useReceiverTypePackageHelp = `The package path to use when looking for use-receiver-type. If not set, the package in the current directory is used.`

	outputFileHelp              = `The generated file name containing the routes function and receiver interface.`
	outputReceiverInterfaceHelp = `The interface name in the generated output file listing the methods used by handler routes in the routes function.`
	outputRoutesFuncHelp        = `The function name for the package registering handler functions on an *"net/http".ServeMux.
This function also receives an argument with a type matching the name given by output-receiver-interface.`
	outputTemplateDataTypeHelp       = `The type name for the template data passed to root route templates.`
	outputTemplateRoutePathsTypeHelp = `The type name for the type with path constructor helper methods.`

	outputRoutesFuncWithLoggerParamHelp = `Adds a *slog.Logger parameter to the generated routes function and uses it to log ExecuteTemplate errors and debug information in handlers.`
	outputRoutesFuncWithPathPrefixHelp  = `Adds a pathPrefix string parameter to the generated routes function and uses it in each path generator method.`
	outputMultipleFilesHelp             = `Split generated routes into separate files per template source file. By default, all routes are written to a single file.`

	errIdentSuffix = " value must be a well-formed Go identifier"
)

const (
	defaultTemplatesVariableName      = "templates"
	defaultRoutesFunctionName         = "TemplateRoutes"
	defaultOutputFileName             = "template_routes.go"
	defaultReceiverInterfaceName      = "RoutesReceiver"
	defaultTemplateRoutePathsTypeName = "TemplateRoutePaths"
	defaultTemplateDataTypeName       = "TemplateData"
	defaultPackageName                = "main"
)

func applyDefaults(config *generate.RoutesFileConfiguration) {
	config.PackageName = cmp.Or(config.PackageName, defaultPackageName)
	config.TemplatesVariable = cmp.Or(config.TemplatesVariable, defaultTemplatesVariableName)
	config.RoutesFunction = cmp.Or(config.RoutesFunction, defaultRoutesFunctionName)
	config.ReceiverInterface = cmp.Or(config.ReceiverInterface, defaultReceiverInterfaceName)
	config.TemplateDataType = cmp.Or(config.TemplateDataType, defaultTemplateDataTypeName)
	config.TemplateRoutePathsTypeName = cmp.Or(config.TemplateRoutePathsTypeName, defaultTemplateRoutePathsTypeName)
}

func newRoutesFileConfiguration(args []string, stderr io.Writer) (generate.RoutesFileConfiguration, error) {
	var g generate.RoutesFileConfiguration
	flagSet := routesFileConfigurationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(useTemplatesVariable + errIdentSuffix)
	}
	if g.RoutesFunction != "" && !token.IsIdentifier(g.RoutesFunction) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputRoutesFunc + errIdentSuffix)
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(useReceiverType + errIdentSuffix)
	}
	if g.ReceiverInterface != "" && !token.IsIdentifier(g.ReceiverInterface) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputReceiverInterface + errIdentSuffix)
	}
	if g.TemplateDataType != "" && !token.IsIdentifier(g.TemplateDataType) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputTemplateDataType + errIdentSuffix)
	}
	if g.TemplateRoutePathsTypeName != "" && !token.IsIdentifier(g.TemplateRoutePathsTypeName) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputTemplateRoutePathsType + errIdentSuffix)
	}
	if g.OutputFileName != "" && filepath.Ext(g.OutputFileName) != ".go" {
		return generate.RoutesFileConfiguration{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func newCheckConfiguration(args []string, stderr io.Writer) (analysis.CheckConfiguration, error) {
	var g analysis.CheckConfiguration
	flagSet := checkFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return analysis.CheckConfiguration{}, fmt.Errorf(useTemplatesVariable + errIdentSuffix)
	}
	return g, nil
}

func newListRoutesConfiguration(args []string, stderr io.Writer) (analysis.DefinitionsConfiguration, error) {
	var g analysis.DefinitionsConfiguration
	flagSet := documentationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return analysis.DefinitionsConfiguration{}, fmt.Errorf(useTemplatesVariable + errIdentSuffix)
	}
	if g.TemplatesVariable == "" {
		return analysis.DefinitionsConfiguration{}, fmt.Errorf("no template variable specified")
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return analysis.DefinitionsConfiguration{}, fmt.Errorf(useReceiverType + errIdentSuffix)
	}
	return g, nil
}

func newTemplateSourceConfiguration(args []string, stderr io.Writer) (analysis.TemplateSourceConfiguration, error) {
	var g analysis.TemplateSourceConfiguration
	flagSet := templateSourceFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable == "" {
		g.TemplatesVariable = defaultTemplatesVariableName
	}
	return g, nil
}

func newListTemplateCallersConfiguration(args []string, stderr io.Writer) (analysis.TemplateCallersConfiguration, error) {
	var g analysis.TemplateCallersConfiguration
	flagSet := listTemplateCallersFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable == "" {
		g.TemplatesVariable = defaultTemplatesVariableName
	}
	return g, nil
}

func newListTemplateCallsConfiguration(args []string, stderr io.Writer) (analysis.TemplateCallsConfiguration, error) {
	var g analysis.TemplateCallsConfiguration
	flagSet := listTemplateCallsFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable == "" {
		g.TemplatesVariable = defaultTemplatesVariableName
	}
	return g, nil
}

// addUseTemplatesVarToFlagSet was split out because it is used for a few different commands
func addUseTemplatesVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useTemplatesVariable, defaultTemplatesVariableName, useTemplatesVariableHelp)
	flagSet.StringVar(out, deprecatedTemplatesVariable, defaultTemplatesVariableName, "DEPRECATED: use --"+useTemplatesVariable+" instead. "+useTemplatesVariableHelp)
	markDeprecated(flagSet, deprecatedTemplatesVariable, useTemplatesVariable)
}

func addUseReceiverTypeVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useReceiverType, "", useReceiverTypeHelp)
}

func adUseReceiverTypePackageVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useReceiverTypePackage, "", useReceiverTypePackageHelp)
}

func addOutputFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.OutputFileName, outputFile, defaultOutputFileName, outputFileHelp)
	flagSet.StringVar(&g.ReceiverInterface, outputReceiverInterface, defaultReceiverInterfaceName, outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, outputRoutesFunc, defaultRoutesFunctionName, outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, outputTemplateDataType, defaultTemplateDataTypeName, outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, outputTemplateRoutePathsType, defaultTemplateRoutePathsTypeName, outputTemplateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.Logger, outputRoutesFuncWithLoggerParam, false, outputRoutesFuncWithLoggerParamHelp)
	flagSet.BoolVar(&g.PathPrefix, outputRoutesFuncWithPathPrefix, false, outputRoutesFuncWithPathPrefixHelp)
	flagSet.BoolVar(&g.OutputMultipleFiles, outputMultipleFiles, false, outputMultipleFilesHelp)
}

func addVerboseFlagToFlagSet(flagSet *pflag.FlagSet, out *bool) {
	flagSet.BoolVarP(out, "verbose", "v", false, "verbose log output")
}

func addDeprecatedUseFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	addDeprecatedReceiverType(flagSet, &g.ReceiverType)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedReceiverTypePackage, "", "DEPRECATED: use --"+useReceiverTypePackage+" instead. "+useReceiverTypePackageHelp)
	flagSet.StringVar(&g.TemplatesVariable, deprecatedFindTemplatesVariable, defaultTemplatesVariableName, "DEPRECATED: use --"+useTemplatesVariable+" instead. "+useTemplatesVariableHelp)
	flagSet.StringVar(&g.ReceiverType, deprecatedFindReceiverType, "", "DEPRECATED: use --"+useReceiverType+" instead. "+useReceiverTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedFindReceiverTypePackage, "", "DEPRECATED: use --"+useReceiverTypePackage+" instead. "+useReceiverTypePackageHelp)

	markDeprecated(flagSet, deprecatedReceiverTypePackage, useReceiverTypePackage)
	markDeprecated(flagSet, deprecatedFindTemplatesVariable, useTemplatesVariable)
	markDeprecated(flagSet, deprecatedFindReceiverType, useReceiverType)
	markDeprecated(flagSet, deprecatedFindReceiverTypePackage, useReceiverTypePackage)
}

func addDeprecatedReceiverType(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, deprecatedReceiverType, "", "DEPRECATED: use --"+useReceiverType+" instead. "+useReceiverTypeHelp)
	markDeprecated(flagSet, deprecatedReceiverType, useReceiverType)
}

func addDeprecatedOutputFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.ReceiverInterface, deprecatedReceiverInterface, defaultReceiverInterfaceName, "DEPRECATED: use --"+outputReceiverInterface+" instead. "+outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, deprecatedRoutesFunc, defaultRoutesFunctionName, "DEPRECATED: use --"+outputRoutesFunc+" instead. "+outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, deprecatedTemplateDataType, defaultTemplateDataTypeName, "DEPRECATED: use --"+outputTemplateDataType+" instead. "+outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, deprecatedTemplateRoutePathsType, defaultTemplateRoutePathsTypeName, "DEPRECATED: use --"+outputTemplateRoutePathsType+" instead. "+outputTemplateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.Logger, deprecatedLogger, false, "DEPRECATED: use --"+outputRoutesFuncWithLoggerParam+" instead. "+outputRoutesFuncWithLoggerParamHelp)
	flagSet.BoolVar(&g.PathPrefix, deprecatedPathPrefix, false, "DEPRECATED: use --"+outputRoutesFuncWithPathPrefix+" instead. "+outputRoutesFuncWithPathPrefixHelp)

	markDeprecated(flagSet, deprecatedReceiverInterface, outputReceiverInterface)
	markDeprecated(flagSet, deprecatedRoutesFunc, outputRoutesFunc)
	markDeprecated(flagSet, deprecatedTemplateDataType, outputTemplateDataType)
	markDeprecated(flagSet, deprecatedTemplateRoutePathsType, outputTemplateRoutePathsType)
	markDeprecated(flagSet, deprecatedLogger, outputRoutesFuncWithLoggerParam)
	markDeprecated(flagSet, deprecatedPathPrefix, outputRoutesFuncWithPathPrefix)
}

func markDeprecated(flagSet *pflag.FlagSet, name, replacement string) {
	if err := flagSet.MarkDeprecated(name, "use --"+replacement+" instead"); err != nil {
		panic(err)
	}
}

func routesFileConfigurationFlagSet(g *generate.RoutesFileConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("generate", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)
	addUseReceiverTypeVarToFlagSet(flagSet, &g.ReceiverType)
	adUseReceiverTypePackageVarToFlagSet(flagSet, &g.ReceiverPackage)
	addVerboseFlagToFlagSet(flagSet, &g.Verbose)

	addOutputFlagsToFlagSet(flagSet, g)
	addDeprecatedUseFlagsToFlagSet(flagSet, g)
	addDeprecatedOutputFlagsToFlagSet(flagSet, g)

	return flagSet
}

func checkFlagSet(g *analysis.CheckConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("check", pflag.ContinueOnError)
	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)
	addVerboseFlagToFlagSet(flagSet, &g.Verbose)
	var rt string
	addDeprecatedReceiverType(flagSet, &rt)
	return flagSet
}

func documentationFlagSet(g *analysis.DefinitionsConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("documentation", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)
	addUseReceiverTypeVarToFlagSet(flagSet, &g.ReceiverType)
	adUseReceiverTypePackageVarToFlagSet(flagSet, &g.ReceiverPackage)

	addVerboseFlagToFlagSet(flagSet, &g.Verbose)

	return flagSet
}

func templateSourceFlagSet(g *analysis.TemplateSourceConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("documentation source", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)

	flagSet.StringVar(&g.TemplateName, "name", "", "select the template with the exact name")

	return flagSet
}

func listTemplateCallersFlagSet(g *analysis.TemplateCallersConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("list-template-callers", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)

	flagSet.StringArrayVar(&g.FilterTemplates, "template", nil, "filter by template name (can specify multiple times)")

	return flagSet
}

func listTemplateCallsFlagSet(g *analysis.TemplateCallsConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("list-template-calls", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)

	flagSet.StringArrayVar(&g.FilterTemplates, "template", nil, "filter by template name (can specify multiple times)")

	return flagSet
}
