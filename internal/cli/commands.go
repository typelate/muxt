package cli

import (
	"bytes"
	"cmp"
	_ "embed"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"

	"github.com/spf13/pflag"

	"github.com/typelate/muxt/internal/analysis"
	"github.com/typelate/muxt/internal/asteval"
	"github.com/typelate/muxt/internal/generate"
)

func Commands(wd string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	if len(args) <= 1 {
		return writeHelp(stdout)
	}
	args = args[1:]
	var err error
	wd, args, err = global(wd, args, stderr)
	if err != nil {
		return err
	}
	switch cmd, cmdArgs := args[0], args[1:]; cmd {
	case "help":
		return writeHelp(stdout)
	case "generate", "gen", "g":
		return generateCommand(wd, cmdArgs, getEnv, stdout, stderr)
	case "version", "v":
		return versionCommand(cmdArgs, stdout, stderr)
	case "check", "chk", "c":
		return checkCommand(wd, cmdArgs, stderr)
	case "documentation", "docs", "doc", "d":
		return documentationCommand(wd, cmdArgs, stdout, stderr)
	default:
		return fmt.Errorf("unknown command")
	}
}

func checkCommand(workingDirectory string, args []string, stderr io.Writer) error {
	config, err := newCheckConfiguration(args, stderr)
	if err != nil {
		return err
	}
	fileSet, pl, err := asteval.LoadPackages(workingDirectory)
	if err != nil {
		return err
	}
	logger := log.New(stderr, "", 0)
	if err := analysis.Check(config, workingDirectory, logger, fileSet, pl); err != nil {
		return fmt.Errorf("fail: %s", err)
	}
	return nil
}

const (
	codeGenerationComment = `// Code generated by muxt generate %s. DO NOT EDIT.` + "\n"
)

func generateCommand(workingDirectory string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if v, ok := cliVersion(); ok {
		config.MuxtVersion = v
	}
	applyDefaults(&config)
	fileSet, pl, err := asteval.LoadPackages(workingDirectory, config.ReceiverPackage)
	if err != nil {
		return err
	}
	files, err := generate.TemplateRoutesFile(workingDirectory, config, fileSet, pl, log.New(stdout, "", 0))
	if err != nil {
		return err
	}

	for _, file := range files {
		var sb bytes.Buffer
		writeCodeGenerationComment(&sb, args)
		sb.WriteString(file.Content)
		if err := os.WriteFile(file.Path, sb.Bytes(), 0o644); err != nil {
			return err
		}
	}
	return nil
}

func writeCodeGenerationComment(w io.StringWriter, args []string) {
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationComment, strings.TrimSpace(strings.Join(args, " "))))
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n\n")
	}
}

//go:embed help.txt
var helpText string

func writeHelp(stdout io.Writer) error {
	var help strings.Builder
	help.WriteString(helpText)
	flagSet := routesFileConfigurationFlagSet(new(generate.RoutesFileConfiguration))
	flagSet.SetOutput(&help)
	flagSet.PrintDefaults()
	_, err := fmt.Fprint(stdout, help.String())
	return err
}

func documentationCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newDocumentationConfiguration(args, stderr)
	if err != nil {
		return err
	}
	fileSet, pl, err := asteval.LoadPackages(wd, config.ReceiverPackage)
	if err != nil {
		return err
	}
	return analysis.Documentation(config, stdout, wd, fileSet, pl)
}

func versionCommand(args []string, stdout, stderr io.Writer) error {
	var verbose bool
	flagSet := pflag.NewFlagSet("version", pflag.ContinueOnError)
	flagSet.SetOutput(stderr)
	flagSet.BoolVarP(&verbose, "verbose", "v", false, "verbose output")
	if err := flagSet.Parse(args); err != nil {
		return err
	}

	v, ok := cliVersion()
	if !ok {
		return fmt.Errorf("missing CLI version")
	}
	if _, err := fmt.Fprintln(stdout, v); err != nil {
		return err
	}

	if verbose {
		bi, ok := debug.ReadBuildInfo()
		if ok {
			if _, err := fmt.Fprintf(stdout, "go version: %s\n", bi.GoVersion); err != nil {
				return err
			}
		}
	}

	return nil
}

func cliVersion() (string, bool) {
	bi, ok := debug.ReadBuildInfo()
	if !ok || bi.Main.Version == "" {
		return "", false
	}
	return bi.Main.Version, true
}

func global(wd string, args []string, stdout io.Writer) (string, []string, error) {
	var changeDir string
	flagSet := pflag.NewFlagSet("muxt global", pflag.ExitOnError)
	flagSet.SetOutput(stdout)
	flagSet.SetInterspersed(false)
	flagSet.StringVarP(&changeDir, "C", "C", "", "change root directory")
	if err := flagSet.Parse(args); err != nil {
		return "", nil, err
	}
	if filepath.IsAbs(changeDir) {
		return changeDir, flagSet.Args(), nil
	}
	cd, err := filepath.Abs(filepath.Join(wd, changeDir))
	if err != nil {
		return "", nil, err
	}
	return cd, flagSet.Args(), nil
}

const (
	// New flag names with clear prefixes
	useTemplatesVariable            = "use-templates-variable"
	useReceiverType                 = "use-receiver-type"
	useReceiverTypePackage          = "use-receiver-type-package"
	outputFile                      = "output-file"
	outputReceiverInterface         = "output-receiver-interface"
	outputRoutesFunc                = "output-routes-func"
	outputTemplateDataType          = "output-template-data-type"
	outputTemplateRoutePathsType    = "output-template-route-paths-type"
	outputRoutesFuncWithLoggerParam = "output-routes-func-with-logger-param"
	outputRoutesFuncWithPathPrefix  = "output-routes-func-with-path-prefix-param"

	// Deprecated feature flag names
	deprecatedPathPrefix = "path-prefix"
	deprecatedLogger     = "logger"

	// Deprecated flag names (for backward compatibility)
	deprecatedTemplatesVariable       = "templates-variable"
	deprecatedReceiverType            = "receiver-type"
	deprecatedReceiverTypePackage     = "receiver-type-package"
	deprecatedReceiverInterface       = "receiver-interface"
	deprecatedRoutesFunc              = "routes-func"
	deprecatedTemplateDataType        = "template-data-type"
	deprecatedTemplateRoutePathsType  = "template-route-paths-type"
	deprecatedFindTemplatesVariable   = "find-templates-variable"
	deprecatedFindReceiverType        = "find-receiver-type"
	deprecatedFindReceiverTypePackage = "find-receiver-type-package"

	// Help text
	useTemplatesVariableHelp   = `the name of the global variable with type *"html/template".Template in the working directory package.`
	useReceiverTypeHelp        = `The type name for a named type to use for looking up method signatures. If not set, all methods added to the receiver interface will have inferred signatures with argument types based on the argument identifier names. The inferred method signatures always return a single result of type any.`
	useReceiverTypePackageHelp = `The package path to use when looking for use-receiver-type. If not set, the package in the current directory is used.`

	outputFileHelp              = `The generated file name containing the routes function and receiver interface.`
	outputReceiverInterfaceHelp = `The interface name in the generated output file listing the methods used by handler routes in the routes function.`
	outputRoutesFuncHelp        = `The function name for the package registering handler functions on an *"net/http".ServeMux.
This function also receives an argument with a type matching the name given by output-receiver-interface.`
	outputTemplateDataTypeHelp       = `The type name for the template data passed to root route templates.`
	outputTemplateRoutePathsTypeHelp = `The type name for the type with path constructor helper methods.`

	outputRoutesFuncWithLoggerParamHelp = `Adds a *slog.Logger parameter to the generated routes function and uses it to log ExecuteTemplate errors and debug information in handlers.`
	outputRoutesFuncWithPathPrefixHelp  = `Adds a pathPrefix string parameter to the generated routes function and uses it in each path generator method.`

	errIdentSuffix = " value must be a well-formed Go identifier"
)

const (
	defaultTemplatesVariableName      = "templates"
	defaultRoutesFunctionName         = "TemplateRoutes"
	defaultOutputFileName             = "template_routes.go"
	defaultReceiverInterfaceName      = "RoutesReceiver"
	defaultTemplateRoutePathsTypeName = "TemplateRoutePaths"
	defaultTemplateDataTypeName       = "TemplateData"
	defaultPackageName                = "main"
)

func applyDefaults(config *generate.RoutesFileConfiguration) {
	config.PackageName = cmp.Or(config.PackageName, defaultPackageName)
	config.TemplatesVariable = cmp.Or(config.TemplatesVariable, defaultTemplatesVariableName)
	config.RoutesFunction = cmp.Or(config.RoutesFunction, defaultRoutesFunctionName)
	config.ReceiverInterface = cmp.Or(config.ReceiverInterface, defaultReceiverInterfaceName)
	config.TemplateDataType = cmp.Or(config.TemplateDataType, defaultTemplateDataTypeName)
	config.TemplateRoutePathsTypeName = cmp.Or(config.TemplateRoutePathsTypeName, defaultTemplateRoutePathsTypeName)
}

func newRoutesFileConfiguration(args []string, stderr io.Writer) (generate.RoutesFileConfiguration, error) {
	var g generate.RoutesFileConfiguration
	flagSet := routesFileConfigurationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(useTemplatesVariable + errIdentSuffix)
	}
	if g.RoutesFunction != "" && !token.IsIdentifier(g.RoutesFunction) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputRoutesFunc + errIdentSuffix)
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(useReceiverType + errIdentSuffix)
	}
	if g.ReceiverInterface != "" && !token.IsIdentifier(g.ReceiverInterface) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputReceiverInterface + errIdentSuffix)
	}
	if g.TemplateDataType != "" && !token.IsIdentifier(g.TemplateDataType) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputTemplateDataType + errIdentSuffix)
	}
	if g.TemplateRoutePathsTypeName != "" && !token.IsIdentifier(g.TemplateRoutePathsTypeName) {
		return generate.RoutesFileConfiguration{}, fmt.Errorf(outputTemplateRoutePathsType + errIdentSuffix)
	}
	if g.OutputFileName != "" && filepath.Ext(g.OutputFileName) != ".go" {
		return generate.RoutesFileConfiguration{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func newCheckConfiguration(args []string, stderr io.Writer) (analysis.CheckConfiguration, error) {
	var g analysis.CheckConfiguration
	flagSet := checkFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return analysis.CheckConfiguration{}, fmt.Errorf(useTemplatesVariable + errIdentSuffix)
	}
	return g, nil
}

func newDocumentationConfiguration(args []string, stderr io.Writer) (analysis.DocumentationConfiguration, error) {
	var g analysis.DocumentationConfiguration
	flagSet := documentationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return analysis.DocumentationConfiguration{}, fmt.Errorf(useTemplatesVariable + errIdentSuffix)
	}
	if g.TemplatesVariable == "" {
		return analysis.DocumentationConfiguration{}, fmt.Errorf("no template variable specified")
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return analysis.DocumentationConfiguration{}, fmt.Errorf(useReceiverType + errIdentSuffix)
	}
	return g, nil
}

// addUseTemplatesVarToFlagSet was split out because it is used for a few different commands
func addUseTemplatesVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useTemplatesVariable, defaultTemplatesVariableName, useTemplatesVariableHelp)
	flagSet.StringVar(out, deprecatedTemplatesVariable, defaultTemplatesVariableName, "DEPRECATED: use --"+useTemplatesVariable+" instead. "+useTemplatesVariableHelp)
	markDeprecated(flagSet, deprecatedTemplatesVariable, useTemplatesVariable)
}

func addUseReceiverTypeVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useReceiverType, "", useReceiverTypeHelp)
}

func adUseReceiverTypePackageVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useReceiverTypePackage, "", useReceiverTypePackageHelp)
}

func addOutputFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.OutputFileName, outputFile, defaultOutputFileName, outputFileHelp)
	flagSet.StringVar(&g.ReceiverInterface, outputReceiverInterface, defaultReceiverInterfaceName, outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, outputRoutesFunc, defaultRoutesFunctionName, outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, outputTemplateDataType, defaultTemplateDataTypeName, outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, outputTemplateRoutePathsType, defaultTemplateRoutePathsTypeName, outputTemplateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.Logger, outputRoutesFuncWithLoggerParam, false, outputRoutesFuncWithLoggerParamHelp)
	flagSet.BoolVar(&g.PathPrefix, outputRoutesFuncWithPathPrefix, false, outputRoutesFuncWithPathPrefixHelp)
}

func addVerboseFlagToFlagSet(flagSet *pflag.FlagSet, out *bool) {
	flagSet.BoolVarP(out, "verbose", "v", false, "verbose log output")
}

func addDeprecatedUseFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.ReceiverType, deprecatedReceiverType, "", "DEPRECATED: use --"+useReceiverType+" instead. "+useReceiverTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedReceiverTypePackage, "", "DEPRECATED: use --"+useReceiverTypePackage+" instead. "+useReceiverTypePackageHelp)
	flagSet.StringVar(&g.TemplatesVariable, deprecatedFindTemplatesVariable, defaultTemplatesVariableName, "DEPRECATED: use --"+useTemplatesVariable+" instead. "+useTemplatesVariableHelp)
	flagSet.StringVar(&g.ReceiverType, deprecatedFindReceiverType, "", "DEPRECATED: use --"+useReceiverType+" instead. "+useReceiverTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedFindReceiverTypePackage, "", "DEPRECATED: use --"+useReceiverTypePackage+" instead. "+useReceiverTypePackageHelp)

	markDeprecated(flagSet, deprecatedReceiverType, useReceiverType)
	markDeprecated(flagSet, deprecatedReceiverTypePackage, useReceiverTypePackage)
	markDeprecated(flagSet, deprecatedFindTemplatesVariable, useTemplatesVariable)
	markDeprecated(flagSet, deprecatedFindReceiverType, useReceiverType)
	markDeprecated(flagSet, deprecatedFindReceiverTypePackage, useReceiverTypePackage)
}

func addDeprecatedOutputFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.ReceiverInterface, deprecatedReceiverInterface, defaultReceiverInterfaceName, "DEPRECATED: use --"+outputReceiverInterface+" instead. "+outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, deprecatedRoutesFunc, defaultRoutesFunctionName, "DEPRECATED: use --"+outputRoutesFunc+" instead. "+outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, deprecatedTemplateDataType, defaultTemplateDataTypeName, "DEPRECATED: use --"+outputTemplateDataType+" instead. "+outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, deprecatedTemplateRoutePathsType, defaultTemplateRoutePathsTypeName, "DEPRECATED: use --"+outputTemplateRoutePathsType+" instead. "+outputTemplateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.Logger, deprecatedLogger, false, "DEPRECATED: use --"+outputRoutesFuncWithLoggerParam+" instead. "+outputRoutesFuncWithLoggerParamHelp)
	flagSet.BoolVar(&g.PathPrefix, deprecatedPathPrefix, false, "DEPRECATED: use --"+outputRoutesFuncWithPathPrefix+" instead. "+outputRoutesFuncWithPathPrefixHelp)

	markDeprecated(flagSet, deprecatedReceiverInterface, outputReceiverInterface)
	markDeprecated(flagSet, deprecatedRoutesFunc, outputRoutesFunc)
	markDeprecated(flagSet, deprecatedTemplateDataType, outputTemplateDataType)
	markDeprecated(flagSet, deprecatedTemplateRoutePathsType, outputTemplateRoutePathsType)
	markDeprecated(flagSet, deprecatedLogger, outputRoutesFuncWithLoggerParam)
	markDeprecated(flagSet, deprecatedPathPrefix, outputRoutesFuncWithPathPrefix)
}

func markDeprecated(flagSet *pflag.FlagSet, name, replacement string) {
	if err := flagSet.MarkDeprecated(name, "use --"+replacement+" instead"); err != nil {
		panic(err)
	}
}

func routesFileConfigurationFlagSet(g *generate.RoutesFileConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("generate", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)
	addUseReceiverTypeVarToFlagSet(flagSet, &g.ReceiverType)
	adUseReceiverTypePackageVarToFlagSet(flagSet, &g.ReceiverPackage)
	addVerboseFlagToFlagSet(flagSet, &g.Verbose)

	addOutputFlagsToFlagSet(flagSet, g)
	addDeprecatedUseFlagsToFlagSet(flagSet, g)
	addDeprecatedOutputFlagsToFlagSet(flagSet, g)

	return flagSet
}

func checkFlagSet(g *analysis.CheckConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("check", pflag.ContinueOnError)
	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)
	addVerboseFlagToFlagSet(flagSet, &g.Verbose)
	return flagSet
}

func documentationFlagSet(g *analysis.DocumentationConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("documentation", pflag.ContinueOnError)

	addUseTemplatesVarToFlagSet(flagSet, &g.TemplatesVariable)
	addUseReceiverTypeVarToFlagSet(flagSet, &g.ReceiverType)
	adUseReceiverTypePackageVarToFlagSet(flagSet, &g.ReceiverPackage)

	addVerboseFlagToFlagSet(flagSet, &g.Verbose)

	return flagSet
}
