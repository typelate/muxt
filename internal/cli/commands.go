package cli

import (
	"bytes"
	"cmp"
	_ "embed"
	"encoding/json"
	"errors"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime/debug"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"

	"github.com/typelate/muxt/internal/analysis"
	"github.com/typelate/muxt/internal/asteval"
	"github.com/typelate/muxt/internal/generate"
)

const (
	generateCommandName            = "generate"
	versionCommandName             = "version"
	checkCommandName               = "check"
	listTemplateCallersCommandName = "list-template-callers"
	listTemplateCallsCommandName   = "list-template-calls"
)

func Commands(wd string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	var changeDir string
	workingDirectory := &wd

	var rootCommandConfig analysis.DefinitionsConfiguration
	rootCmd := &cobra.Command{
		Use:   "muxt [command]",
		Short: `Generate HTTP Endpoints from HTML Templates`,
		PersistentPreRunE: func(cmd *cobra.Command, _ []string) error {
			if changeDir == "" {
				return nil
			}
			var newWd string
			if filepath.IsAbs(changeDir) {
				newWd = changeDir
			} else {
				cd, err := filepath.Abs(filepath.Join(wd, changeDir))
				if err != nil {
					return err
				}
				newWd = cd
			}
			*workingDirectory = newWd
			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			fileSet, pl, err := asteval.LoadPackages(*workingDirectory, rootCommandConfig.ReceiverPackage)
			if err != nil {
				return err
			}
			result, err := analysis.NewRoutes(rootCommandConfig, *workingDirectory, fileSet, pl)
			if err != nil {
				return err
			}
			return writeResult(cmd, cmd.OutOrStdout(), result)
		},
	}
	rootCmd.PersistentFlags().StringVarP(&changeDir, "change-directory", "C", "", "change the working directory")

	addUseTemplatesVarToFlagSet(rootCmd.Flags(), &rootCommandConfig.TemplatesVariable)
	addUseReceiverTypeVarToFlagSet(rootCmd.Flags(), &rootCommandConfig.ReceiverType)
	adUseReceiverTypePackageVarToFlagSet(rootCmd.Flags(), &rootCommandConfig.ReceiverPackage)
	addVerboseFlagToFlagSet(rootCmd.Flags(), &rootCommandConfig.Verbose)
	rootCmd.Flags().String("format", "text", "output format (text or json)")

	rootCmd.SetArgs(args)
	rootCmd.SetOut(stdout)
	rootCmd.SetErr(stderr)

	rootCmd.AddCommand(
		generateCommand(workingDirectory),
		versionCommand(),
		checkCommand(workingDirectory),
		listTemplateCallersCommand(workingDirectory),
		listTemplateCallsCommand(workingDirectory),
	)

	// Ensure all flag sets route their output (including deprecation warnings) to stderr
	for _, cmd := range rootCmd.Commands() {
		cmd.Flags().SetOutput(stderr)
		cmd.PersistentFlags().SetOutput(stderr)
	}
	rootCmd.Flags().SetOutput(stderr)
	rootCmd.PersistentFlags().SetOutput(stderr)

	return rootCmd.Execute()
}

func checkCommand(workingDirectory *string) *cobra.Command {
	var config analysis.CheckConfiguration
	var rt string

	cmd := &cobra.Command{
		Use:     checkCommandName,
		Aliases: []string{"c"},
		Short:   "Check templates for errors",
		RunE: func(cmd *cobra.Command, args []string) error {
			if config.TemplatesVariable != "" && !token.IsIdentifier(config.TemplatesVariable) {
				return fmt.Errorf(useTemplatesVariable + errIdentSuffix)
			}

			fileSet, pl, err := asteval.LoadPackages(*workingDirectory)
			if err != nil {
				return err
			}
			logger := log.New(cmd.ErrOrStderr(), "", 0)
			if err := analysis.Check(config, *workingDirectory, logger, fileSet, pl); err != nil {
				return fmt.Errorf("fail: %s", err)
			}
			return nil
		},
	}

	addUseTemplatesVarToFlagSet(cmd.Flags(), &config.TemplatesVariable)
	addVerboseFlagToFlagSet(cmd.Flags(), &config.Verbose)
	addDeprecatedReceiverType(cmd.Flags(), &rt)

	return cmd
}

const (
	codeGenerationComment = `// Code generated by muxt generate %s. DO NOT EDIT.` + "\n"
)

func addGenerateFlags(flagSet *pflag.FlagSet, config *generate.RoutesFileConfiguration) {
	addUseTemplatesVarToFlagSet(flagSet, &config.TemplatesVariable)
	addUseReceiverTypeVarToFlagSet(flagSet, &config.ReceiverType)
	adUseReceiverTypePackageVarToFlagSet(flagSet, &config.ReceiverPackage)
	addVerboseFlagToFlagSet(flagSet, &config.Verbose)

	addOutputFlagsToFlagSet(flagSet, config)
	addDeprecatedUseFlagsToFlagSet(flagSet, config)
	addDeprecatedOutputFlagsToFlagSet(flagSet, config)
}

func generateCommand(workingDirectory *string) *cobra.Command {
	var config generate.RoutesFileConfiguration

	cmd := &cobra.Command{
		Use:     generateCommandName,
		Aliases: []string{"gen", "g"},
		Short:   "Generate HTTP routes from templates",
		RunE: func(cmd *cobra.Command, args []string) error {
			stdout := cmd.OutOrStdout()
			if config.TemplatesVariable != "" && !token.IsIdentifier(config.TemplatesVariable) {
				return fmt.Errorf(useTemplatesVariable + errIdentSuffix)
			}
			if config.RoutesFunction != "" && !token.IsIdentifier(config.RoutesFunction) {
				return fmt.Errorf(outputRoutesFunc + errIdentSuffix)
			}
			if config.ReceiverType != "" && !token.IsIdentifier(config.ReceiverType) {
				return fmt.Errorf(useReceiverType + errIdentSuffix)
			}
			if config.ReceiverInterface != "" && !token.IsIdentifier(config.ReceiverInterface) {
				return fmt.Errorf(outputReceiverInterface + errIdentSuffix)
			}
			if config.TemplateDataType != "" && !token.IsIdentifier(config.TemplateDataType) {
				return fmt.Errorf(outputTemplateDataType + errIdentSuffix)
			}
			if config.TemplateRoutePathsTypeName != "" && !token.IsIdentifier(config.TemplateRoutePathsTypeName) {
				return fmt.Errorf(outputTemplateRoutePathsType + errIdentSuffix)
			}
			if config.OutputFileName != "" && filepath.Ext(config.OutputFileName) != ".go" {
				return fmt.Errorf("output filename must use .go extension")
			}

			if v, ok := cliVersion(); ok {
				config.MuxtVersion = v
			}
			applyDefaults(&config)
			fileSet, pl, err := asteval.LoadPackages(*workingDirectory, config.ReceiverPackage)
			if err != nil {
				return err
			}
			files, err := generate.TemplateRoutesFile(*workingDirectory, config, fileSet, pl, log.New(stdout, "", 0))
			if err != nil {
				return err
			}

			// CLEANUP HEURISTIC:
			// We automatically delete muxt-generated files that are no longer needed to avoid
			// manual cleanup when template files are renamed or generation modes change.
			//
			// Files are identified by:
			// 1. Presence of "// Code generated by muxt generate" comment
			// 2. Matching --output-routes-func value (to differentiate multiple route sets)
			//
			// Cleanup scenarios:
			// - Template renamed: old_template_routes_gen.go deleted when template renamed to new.gohtml
			// - Switch to single-file: all per-file *_template_routes_gen.go files deleted
			// - Switch to multi-file: old single template_routes.go overwritten (if same filename)
			// - Routes function unchanged: only deletes files matching current routes function
			//
			// IMPORTANT: If you change --output-routes-func value, old files with the previous
			// routes function name will NOT be deleted (to allow multiple route sets to coexist).
			// To clean up after changing routes function name, manually delete old files or
			// temporarily use the old --output-routes-func value with current templates.

			// Find existing generated files for cleanup
			oldGeneratedFiles, err := generate.FileArguments(*workingDirectory, config.RoutesFunction)
			if err != nil {
				return err
			}

			for oldFilePath, oldArgs := range oldGeneratedFiles {
				var oldConfig generate.RoutesFileConfiguration
				set := pflag.NewFlagSet("parse-old", pflag.ContinueOnError)
				addGenerateFlags(set, &oldConfig)
				set.SetOutput(io.Discard)
				if err := set.Parse(oldArgs); err != nil {
					log.Printf("WARNING: ignored generated file %s because arguments failed to parse: %s", oldFilePath, err)
					continue
				}
				if oldConfig.RoutesFunction != config.RoutesFunction {
					delete(oldGeneratedFiles, oldFilePath)
				}
			}

			// Write new files
			newGeneratedFiles := make(map[string]bool)
			for i, file := range files {
				var sb bytes.Buffer
				writeCodeGenerationComment(&sb, configToArgs(config))
				sb.WriteString(file.Content)
				if err := os.WriteFile(file.Path, sb.Bytes(), 0o644); err != nil {
					for _, f := range files[:i] {
						if rmErr := os.Remove(f.Path); rmErr != nil {
							err = errors.Join(err, rmErr)
						}
					}
					return err
				}
				newGeneratedFiles[file.Path] = true
			}

			// Clean up orphaned files
			// Only deletes files that match the current routes function name but weren't regenerated
			for oldFile := range oldGeneratedFiles {
				if !newGeneratedFiles[oldFile] {
					if err := os.Remove(oldFile); err != nil && !os.IsNotExist(err) {
						return fmt.Errorf("failed to remove orphaned file %s: %w", oldFile, err)
					}
				}
			}

			return nil
		},
	}

	addGenerateFlags(cmd.Flags(), &config)

	return cmd
}

func configToArgs(config generate.RoutesFileConfiguration) []string {
	var args []string

	// Add non-default string flags
	if config.TemplatesVariable != defaultTemplatesVariableName {
		args = append(args, "--"+useTemplatesVariable+"="+config.TemplatesVariable)
	}
	if config.ReceiverType != "" {
		args = append(args, "--"+useReceiverType+"="+config.ReceiverType)
	}
	if config.ReceiverPackage != "" {
		args = append(args, "--"+useReceiverTypePackage+"="+config.ReceiverPackage)
	}
	if config.OutputFileName != defaultOutputFileName {
		args = append(args, "--"+outputFile+"="+config.OutputFileName)
	}
	if config.ReceiverInterface != defaultReceiverInterfaceName {
		args = append(args, "--"+outputReceiverInterface+"="+config.ReceiverInterface)
	}
	if config.RoutesFunction != defaultRoutesFunctionName {
		args = append(args, "--"+outputRoutesFunc+"="+config.RoutesFunction)
	}
	if config.TemplateDataType != defaultTemplateDataTypeName {
		args = append(args, "--"+outputTemplateDataType+"="+config.TemplateDataType)
	}
	if config.TemplateRoutePathsTypeName != defaultTemplateRoutePathsTypeName {
		args = append(args, "--"+outputTemplateRoutePathsType+"="+config.TemplateRoutePathsTypeName)
	}

	// Add boolean flags if true
	if config.Logger {
		args = append(args, "--"+outputRoutesFuncWithLoggerParam)
	}
	if config.PathPrefix {
		args = append(args, "--"+outputRoutesFuncWithPathPrefix)
	}
	if config.OutputMultipleFiles {
		args = append(args, "--"+outputMultipleFiles)
	}

	return args
}

func writeCodeGenerationComment(w io.StringWriter, args []string) {
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationComment, strings.TrimSpace(strings.Join(args, " "))))
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n\n")
	}
}

func listTemplateCallersCommand(wd *string) *cobra.Command {
	var config analysis.TemplateCallersConfiguration

	var patterns []string
	cmd := &cobra.Command{
		Use:     listTemplateCallersCommandName,
		Aliases: []string{"callers"},
		Short:   "List template callers",
		RunE: func(cmd *cobra.Command, args []string) error {
			if config.TemplatesVariable == "" {
				config.TemplatesVariable = defaultTemplatesVariableName
			}
			for _, pattern := range patterns {
				pat, err := regexp.Compile(pattern)
				if err != nil {
					return err
				}
				config.FilterTemplates = append(config.FilterTemplates, pat)
			}

			fileSet, pl, err := asteval.LoadPackages(*wd)
			if err != nil {
				return err
			}
			pkg, glb, ts, err := asteval.LoadTemplates(*wd, config.TemplatesVariable, pl)
			if err != nil {
				return err
			}
			result, err := analysis.NewTemplateCallers(config, fileSet, pkg, glb, ts)
			if err != nil {
				return err
			}
			return writeResult(cmd, cmd.OutOrStdout(), result)
		},
	}

	addUseTemplatesVarToFlagSet(cmd.Flags(), &config.TemplatesVariable)
	cmd.Flags().StringArrayVar(&patterns, "match", nil, "filter by template name (can specify multiple regular expressions)")
	cmd.Flags().String("format", "text", "output format (text or json)")

	return cmd
}

func listTemplateCallsCommand(wd *string) *cobra.Command {
	var config analysis.TemplateCallsConfiguration
	var patterns []string

	cmd := &cobra.Command{
		Use:     listTemplateCallsCommandName,
		Aliases: []string{"calls"},
		Short:   "List template calls",
		RunE: func(cmd *cobra.Command, args []string) error {
			if config.TemplatesVariable == "" {
				config.TemplatesVariable = defaultTemplatesVariableName
			}
			for _, pattern := range patterns {
				pat, err := regexp.Compile(pattern)
				if err != nil {
					return err
				}
				config.FilterTemplates = append(config.FilterTemplates, pat)
			}

			_, pl, err := asteval.LoadPackages(*wd)
			if err != nil {
				return err
			}
			pkg, glb, ts, err := asteval.LoadTemplates(*wd, config.TemplatesVariable, pl)
			if err != nil {
				return err
			}
			result, err := analysis.NewTemplateCalls(config, pkg, glb, ts)
			if err != nil {
				return err
			}
			return writeResult(cmd, cmd.OutOrStdout(), result)
		},
	}

	addUseTemplatesVarToFlagSet(cmd.Flags(), &config.TemplatesVariable)
	cmd.Flags().StringArrayVar(&patterns, "match", nil, "filter by template name (can specify multiple regular expressions)")
	cmd.Flags().String("format", "text", "output format (text or json)")

	return cmd
}

func versionCommand() *cobra.Command {
	var verbose bool

	cmd := &cobra.Command{
		Use:     versionCommandName,
		Aliases: []string{"v"},
		Short:   "Print the version number",
		RunE: func(cmd *cobra.Command, args []string) error {
			v, ok := cliVersion()
			if !ok {
				return fmt.Errorf("missing CLI version")
			}
			if _, err := fmt.Fprintln(cmd.OutOrStdout(), v); err != nil {
				return err
			}

			if verbose {
				bi, ok := debug.ReadBuildInfo()
				if ok {
					if _, err := fmt.Fprintf(cmd.OutOrStdout(), "go version: %s\n", bi.GoVersion); err != nil {
						return err
					}
				}
			}

			return nil
		},
	}

	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "verbose output")

	return cmd
}

func cliVersion() (string, bool) {
	bi, ok := debug.ReadBuildInfo()
	if !ok || bi.Main.Version == "" {
		return "", false
	}
	return bi.Main.Version, true
}

const (
	// New flag names with clear prefixes
	useTemplatesVariable            = "use-templates-variable"
	useReceiverType                 = "use-receiver-type"
	useReceiverTypePackage          = "use-receiver-type-package"
	outputFile                      = "output-file"
	outputReceiverInterface         = "output-receiver-interface"
	outputRoutesFunc                = "output-routes-func"
	outputTemplateDataType          = "output-template-data-type"
	outputTemplateRoutePathsType    = "output-template-route-paths-type"
	outputRoutesFuncWithLoggerParam = "output-routes-func-with-logger-param"
	outputRoutesFuncWithPathPrefix  = "output-routes-func-with-path-prefix-param"
	outputMultipleFiles             = "output-multiple-files"

	// Deprecated feature flag names
	deprecatedPathPrefix = "path-prefix"
	deprecatedLogger     = "logger"

	// Deprecated flag names (for backward compatibility)
	deprecatedTemplatesVariable       = "templates-variable"
	deprecatedReceiverType            = "receiver-type"
	deprecatedReceiverTypePackage     = "receiver-type-package"
	deprecatedReceiverInterface       = "receiver-interface"
	deprecatedRoutesFunc              = "routes-func"
	deprecatedTemplateDataType        = "template-data-type"
	deprecatedTemplateRoutePathsType  = "template-route-paths-type"
	deprecatedFindTemplatesVariable   = "find-templates-variable"
	deprecatedFindReceiverType        = "find-receiver-type"
	deprecatedFindReceiverTypePackage = "find-receiver-type-package"

	// Help text
	useTemplatesVariableHelp   = `the name of the global variable with type *"html/template".Template in the working directory package.`
	useReceiverTypeHelp        = `The type name for a named type to use for looking up method signatures. If not set, all methods added to the receiver interface will have inferred signatures with argument types based on the argument identifier names. The inferred method signatures always return a single result of type any.`
	useReceiverTypePackageHelp = `The package path to use when looking for use-receiver-type. If not set, the package in the current directory is used.`

	outputFileHelp              = `The generated file name containing the routes function and receiver interface.`
	outputReceiverInterfaceHelp = `The interface name in the generated output file listing the methods used by handler routes in the routes function.`
	outputRoutesFuncHelp        = `The function name for the package registering handler functions on an *"net/http".ServeMux.
This function also receives an argument with a type matching the name given by output-receiver-interface.`
	outputTemplateDataTypeHelp       = `The type name for the template data passed to root route templates.`
	outputTemplateRoutePathsTypeHelp = `The type name for the type with path constructor helper methods.`

	outputRoutesFuncWithLoggerParamHelp = `Adds a *slog.Logger parameter to the generated routes function and uses it to log ExecuteTemplate errors and debug information in handlers.`
	outputRoutesFuncWithPathPrefixHelp  = `Adds a pathPrefix string parameter to the generated routes function and uses it in each path generator method.`
	outputMultipleFilesHelp             = `Split generated routes into separate files per template source file. By default, all routes are written to a single file.`

	errIdentSuffix = " value must be a well-formed Go identifier"
)

const (
	defaultTemplatesVariableName      = "templates"
	defaultRoutesFunctionName         = "TemplateRoutes"
	defaultOutputFileName             = "template_routes.go"
	defaultReceiverInterfaceName      = "RoutesReceiver"
	defaultTemplateRoutePathsTypeName = "TemplateRoutePaths"
	defaultTemplateDataTypeName       = "TemplateData"
	defaultPackageName                = "main"
)

func applyDefaults(config *generate.RoutesFileConfiguration) {
	config.PackageName = cmp.Or(config.PackageName, defaultPackageName)
	config.TemplatesVariable = cmp.Or(config.TemplatesVariable, defaultTemplatesVariableName)
	config.RoutesFunction = cmp.Or(config.RoutesFunction, defaultRoutesFunctionName)
	config.ReceiverInterface = cmp.Or(config.ReceiverInterface, defaultReceiverInterfaceName)
	config.TemplateDataType = cmp.Or(config.TemplateDataType, defaultTemplateDataTypeName)
	config.TemplateRoutePathsTypeName = cmp.Or(config.TemplateRoutePathsTypeName, defaultTemplateRoutePathsTypeName)
}

// addUseTemplatesVarToFlagSet was split out because it is used for a few different commands
func addUseTemplatesVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useTemplatesVariable, defaultTemplatesVariableName, useTemplatesVariableHelp)
	flagSet.StringVar(out, deprecatedTemplatesVariable, defaultTemplatesVariableName, "DEPRECATED: use --"+useTemplatesVariable+" instead. "+useTemplatesVariableHelp)
	markDeprecated(flagSet, deprecatedTemplatesVariable, useTemplatesVariable)
}

func addUseReceiverTypeVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useReceiverType, "", useReceiverTypeHelp)
}

func adUseReceiverTypePackageVarToFlagSet(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, useReceiverTypePackage, "", useReceiverTypePackageHelp)
}

func addOutputFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.OutputFileName, outputFile, defaultOutputFileName, outputFileHelp)
	flagSet.StringVar(&g.ReceiverInterface, outputReceiverInterface, defaultReceiverInterfaceName, outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, outputRoutesFunc, defaultRoutesFunctionName, outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, outputTemplateDataType, defaultTemplateDataTypeName, outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, outputTemplateRoutePathsType, defaultTemplateRoutePathsTypeName, outputTemplateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.Logger, outputRoutesFuncWithLoggerParam, false, outputRoutesFuncWithLoggerParamHelp)
	flagSet.BoolVar(&g.PathPrefix, outputRoutesFuncWithPathPrefix, false, outputRoutesFuncWithPathPrefixHelp)
	flagSet.BoolVar(&g.OutputMultipleFiles, outputMultipleFiles, false, outputMultipleFilesHelp)
}

func addVerboseFlagToFlagSet(flagSet *pflag.FlagSet, out *bool) {
	flagSet.BoolVarP(out, "verbose", "v", false, "verbose log output")
}

func addDeprecatedUseFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	addDeprecatedReceiverType(flagSet, &g.ReceiverType)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedReceiverTypePackage, "", "DEPRECATED: use --"+useReceiverTypePackage+" instead. "+useReceiverTypePackageHelp)
	flagSet.StringVar(&g.TemplatesVariable, deprecatedFindTemplatesVariable, defaultTemplatesVariableName, "DEPRECATED: use --"+useTemplatesVariable+" instead. "+useTemplatesVariableHelp)
	flagSet.StringVar(&g.ReceiverType, deprecatedFindReceiverType, "", "DEPRECATED: use --"+useReceiverType+" instead. "+useReceiverTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedFindReceiverTypePackage, "", "DEPRECATED: use --"+useReceiverTypePackage+" instead. "+useReceiverTypePackageHelp)

	markDeprecated(flagSet, deprecatedReceiverTypePackage, useReceiverTypePackage)
	markDeprecated(flagSet, deprecatedFindTemplatesVariable, useTemplatesVariable)
	markDeprecated(flagSet, deprecatedFindReceiverType, useReceiverType)
	markDeprecated(flagSet, deprecatedFindReceiverTypePackage, useReceiverTypePackage)
}

func addDeprecatedReceiverType(flagSet *pflag.FlagSet, out *string) {
	flagSet.StringVar(out, deprecatedReceiverType, "", "DEPRECATED: use --"+useReceiverType+" instead. "+useReceiverTypeHelp)
	markDeprecated(flagSet, deprecatedReceiverType, useReceiverType)
}

func addDeprecatedOutputFlagsToFlagSet(flagSet *pflag.FlagSet, g *generate.RoutesFileConfiguration) {
	flagSet.StringVar(&g.ReceiverInterface, deprecatedReceiverInterface, defaultReceiverInterfaceName, "DEPRECATED: use --"+outputReceiverInterface+" instead. "+outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, deprecatedRoutesFunc, defaultRoutesFunctionName, "DEPRECATED: use --"+outputRoutesFunc+" instead. "+outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, deprecatedTemplateDataType, defaultTemplateDataTypeName, "DEPRECATED: use --"+outputTemplateDataType+" instead. "+outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, deprecatedTemplateRoutePathsType, defaultTemplateRoutePathsTypeName, "DEPRECATED: use --"+outputTemplateRoutePathsType+" instead. "+outputTemplateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.Logger, deprecatedLogger, false, "DEPRECATED: use --"+outputRoutesFuncWithLoggerParam+" instead. "+outputRoutesFuncWithLoggerParamHelp)
	flagSet.BoolVar(&g.PathPrefix, deprecatedPathPrefix, false, "DEPRECATED: use --"+outputRoutesFuncWithPathPrefix+" instead. "+outputRoutesFuncWithPathPrefixHelp)

	markDeprecated(flagSet, deprecatedReceiverInterface, outputReceiverInterface)
	markDeprecated(flagSet, deprecatedRoutesFunc, outputRoutesFunc)
	markDeprecated(flagSet, deprecatedTemplateDataType, outputTemplateDataType)
	markDeprecated(flagSet, deprecatedTemplateRoutePathsType, outputTemplateRoutePathsType)
	markDeprecated(flagSet, deprecatedLogger, outputRoutesFuncWithLoggerParam)
	markDeprecated(flagSet, deprecatedPathPrefix, outputRoutesFuncWithPathPrefix)
}

func markDeprecated(flagSet *pflag.FlagSet, name, replacement string) {
	if err := flagSet.MarkDeprecated(name, "use --"+replacement+" instead"); err != nil {
		panic(err)
	}
}

func writeResult(cmd *cobra.Command, w io.Writer, result io.WriterTo) error {
	format, err := cmd.Flags().GetString("format")
	if err != nil {
		return err
	}
	switch format {
	case "json":
		buf, err := json.MarshalIndent(result, "", "\t")
		if err != nil {
			return err
		}
		_, err = w.Write(buf)
		return err
	case "text":
		_, err := result.WriteTo(w)
		return err
	default:
		return fmt.Errorf("unknown format: %s", format)
	}
}
