package cli

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"

	"github.com/spf13/pflag"

	"github.com/typelate/muxt/internal/muxt"
)

func Commands(wd string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	if len(args) <= 1 {
		return writeHelp(stdout)
	}
	args = args[1:]
	var err error
	wd, args, err = global(wd, args, stderr)
	if err != nil {
		return err
	}
	switch cmd, cmdArgs := args[0], args[1:]; cmd {
	case "help":
		return writeHelp(stdout)
	case "generate", "gen", "g":
		return generateCommand(wd, cmdArgs, getEnv, stdout, stderr)
	case "version", "v":
		return versionCommand(stdout)
	case "check", "c", "typelate":
		return checkCommand(wd, cmdArgs, stderr)
	case "documentation", "docs", "d":
		return documentationCommand(wd, cmdArgs, stdout, stderr)
	default:
		return fmt.Errorf("unknown command")
	}
}

func checkCommand(workingDirectory string, args []string, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if err := muxt.Check(workingDirectory, log.New(stderr, "", 0), config); err != nil {
		return fmt.Errorf("fail: %s", err)
	}
	return nil
}

const (
	codeGenerationComment = `// Code generated by muxt generate %s. DO NOT EDIT.` + "\n"
)

func generateCommand(workingDirectory string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if v, ok := cliVersion(); ok {
		config.MuxtVersion = v
	}
	files, err := muxt.TemplateRoutesFile(workingDirectory, log.New(stdout, "", 0), config)
	if err != nil {
		return err
	}

	for _, file := range files {
		var sb bytes.Buffer
		writeCodeGenerationComment(&sb, args)
		sb.WriteString(file.Content)
		if err := os.WriteFile(file.Path, sb.Bytes(), 0o644); err != nil {
			return err
		}
	}
	return nil
}

func writeCodeGenerationComment(w io.StringWriter, args []string) {
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationComment, strings.Join(args, " ")))
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n")
	}
}

//go:embed help.txt
var helpText string

func writeHelp(stdout io.Writer) error {
	var help strings.Builder
	help.WriteString(helpText)
	flagSet := routesFileConfigurationFlagSet(new(muxt.RoutesFileConfiguration))
	flagSet.SetOutput(&help)
	flagSet.PrintDefaults()
	_, err := fmt.Fprint(stdout, help.String())
	return err
}

func documentationCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	return muxt.Documentation(stdout, wd, config)
}

func versionCommand(stdout io.Writer) error {
	v, ok := cliVersion()
	if !ok {
		return fmt.Errorf("missing CLI version")
	}
	_, err := fmt.Fprintln(stdout, v)
	return err
}

func cliVersion() (string, bool) {
	bi, ok := debug.ReadBuildInfo()
	if !ok || bi.Main.Version == "" {
		return "", false
	}
	return bi.Main.Version, true
}

func global(wd string, args []string, stdout io.Writer) (string, []string, error) {
	var changeDir string
	flagSet := pflag.NewFlagSet("muxt global", pflag.ExitOnError)
	flagSet.SetOutput(stdout)
	flagSet.SetInterspersed(false)
	flagSet.StringVarP(&changeDir, "C", "C", "", "change root directory")
	if err := flagSet.Parse(args); err != nil {
		return "", nil, err
	}
	if filepath.IsAbs(changeDir) {
		return changeDir, flagSet.Args(), nil
	}
	cd, err := filepath.Abs(filepath.Join(wd, changeDir))
	if err != nil {
		return "", nil, err
	}
	return cd, flagSet.Args(), nil
}

const (
	outputFlagNameHelp = `The generated file name containing the routes function and receiver interface.`
	outputFlagName     = "output-file"

	templatesVariableHelp = `the name of the global variable with type *"html/template".Template in the working directory package.`
	templatesVariable     = "templates-variable"

	templateDataType     = "template-data-type"
	templateDataTypeHelp = `The type name for the template data passed to root route templates.`

	routesFuncHelp = `The function name for the package registering handler functions on an *"net/http".ServeMux.
This function also receives an argument with a type matching the name given by receiver-interface.`
	routesFunc = "routes-func"

	receiverStaticTypeHelp = `The type name for a named type to use for looking up method signatures. If not set, all methods added to the receiver interface will have inferred signatures with argument types based on the argument identifier names. The inferred method signatures always return a single result of type any.`
	receiverStaticType     = "receiver-type"

	receiverStaticTypePackageHelp = `The package path to use when looking for receiver-type. If not set, the package in the current directory is used.`
	receiverStaticTypePackage     = "receiver-type-package"

	receiverInterfaceNameHelp = `The interface name in the generated output-file listing the methods used by the handler routes in routes-func.`
	receiverInterfaceName     = "receiver-interface"

	templateRoutePathsType     = "template-route-paths-type"
	templateRoutePathsTypeHelp = `The type name for the type with path constructor helper methods.`

	pathPrefixName     = "path-prefix"
	pathPrefixNameHelp = `Adds a path-prefix parameter to the TemplateRoutes function and use it in each path generator method.`

	loggerName     = "logger"
	loggerNameHelp = `Adds a *slog.Logger parameter to the TemplateRoutes function and uses it to log ExecuteTemplate errors and debug information in handlers.`

	errIdentSuffix = " value must be a well-formed Go identifier"
)

func newRoutesFileConfiguration(args []string, stderr io.Writer) (muxt.RoutesFileConfiguration, error) {
	var g muxt.RoutesFileConfiguration
	flagSet := routesFileConfigurationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(templatesVariable + errIdentSuffix)
	}
	if g.RoutesFunction != "" && !token.IsIdentifier(g.RoutesFunction) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(routesFunc + errIdentSuffix)
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(receiverStaticType + errIdentSuffix)
	}
	if g.ReceiverInterface != "" && !token.IsIdentifier(g.ReceiverInterface) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(receiverInterfaceName + errIdentSuffix)
	}
	if g.TemplateDataType != "" && !token.IsIdentifier(g.TemplateDataType) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(templateDataType + errIdentSuffix)
	}
	if g.TemplateRoutePathsTypeName != "" && !token.IsIdentifier(g.TemplateRoutePathsTypeName) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(templateRoutePathsType + errIdentSuffix)
	}
	if g.OutputFileName != "" && filepath.Ext(g.OutputFileName) != ".go" {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func routesFileConfigurationFlagSet(g *muxt.RoutesFileConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("generate", pflag.ContinueOnError)
	flagSet.StringVar(&g.OutputFileName, outputFlagName, muxt.DefaultOutputFileName, outputFlagNameHelp)
	flagSet.StringVar(&g.TemplatesVariable, templatesVariable, muxt.DefaultTemplatesVariableName, templatesVariableHelp)
	flagSet.StringVar(&g.RoutesFunction, routesFunc, muxt.DefaultRoutesFunctionName, routesFuncHelp)
	flagSet.StringVar(&g.ReceiverType, receiverStaticType, "", receiverStaticTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, receiverStaticTypePackage, "", receiverStaticTypePackageHelp)
	flagSet.StringVar(&g.ReceiverInterface, receiverInterfaceName, muxt.DefaultReceiverInterfaceName, receiverInterfaceNameHelp)
	flagSet.StringVar(&g.TemplateDataType, templateDataType, muxt.DefaultTemplateDataTypeName, templateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, templateRoutePathsType, muxt.DefaultTemplateRoutePathsTypeName, templateRoutePathsTypeHelp)
	flagSet.BoolVar(&g.PathPrefix, pathPrefixName, false, pathPrefixNameHelp)
	flagSet.BoolVar(&g.Logger, loggerName, false, loggerNameHelp)
	return flagSet
}
