package cli

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"

	"github.com/spf13/pflag"

	"github.com/typelate/muxt/internal/muxt"
)

func Commands(wd string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	if len(args) <= 1 {
		return writeHelp(stdout)
	}
	args = args[1:]
	var err error
	wd, args, err = global(wd, args, stderr)
	if err != nil {
		return err
	}
	switch cmd, cmdArgs := args[0], args[1:]; cmd {
	case "help":
		return writeHelp(stdout)
	case "generate", "gen", "g":
		return generateCommand(wd, cmdArgs, getEnv, stdout, stderr)
	case "version", "v":
		return versionCommand(cmdArgs, stdout, stderr)
	case "check", "c", "typelate":
		return checkCommand(wd, cmdArgs, stderr)
	case "documentation", "docs", "d":
		return documentationCommand(wd, cmdArgs, stdout, stderr)
	default:
		return fmt.Errorf("unknown command")
	}
}

func checkCommand(workingDirectory string, args []string, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if err := muxt.Check(workingDirectory, log.New(stderr, "", 0), config); err != nil {
		return fmt.Errorf("fail: %s", err)
	}
	return nil
}

const (
	codeGenerationComment = `// Code generated by muxt generate %s. DO NOT EDIT.` + "\n"
)

func generateCommand(workingDirectory string, args []string, getEnv func(string) string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	if v, ok := cliVersion(); ok {
		config.MuxtVersion = v
	}
	files, err := muxt.TemplateRoutesFile(workingDirectory, log.New(stdout, "", 0), config)
	if err != nil {
		return err
	}

	for _, file := range files {
		var sb bytes.Buffer
		writeCodeGenerationComment(&sb, args)
		sb.WriteString(file.Content)
		if err := os.WriteFile(file.Path, sb.Bytes(), 0o644); err != nil {
			return err
		}
	}
	return nil
}

func writeCodeGenerationComment(w io.StringWriter, args []string) {
	_, _ = w.WriteString(fmt.Sprintf(codeGenerationComment, strings.Join(args, " ")))
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n")
	}
}

//go:embed help.txt
var helpText string

func writeHelp(stdout io.Writer) error {
	var help strings.Builder
	help.WriteString(helpText)
	flagSet := routesFileConfigurationFlagSet(new(muxt.RoutesFileConfiguration))
	flagSet.SetOutput(&help)
	flagSet.PrintDefaults()
	_, err := fmt.Fprint(stdout, help.String())
	return err
}

func documentationCommand(wd string, args []string, stdout, stderr io.Writer) error {
	config, err := newRoutesFileConfiguration(args, stderr)
	if err != nil {
		return err
	}
	return muxt.Documentation(stdout, wd, config)
}

func versionCommand(args []string, stdout, stderr io.Writer) error {
	var verbose bool
	flagSet := pflag.NewFlagSet("version", pflag.ContinueOnError)
	flagSet.SetOutput(stderr)
	flagSet.BoolVarP(&verbose, "verbose", "v", false, "verbose output")
	if err := flagSet.Parse(args); err != nil {
		return err
	}

	v, ok := cliVersion()
	if !ok {
		return fmt.Errorf("missing CLI version")
	}
	if _, err := fmt.Fprintln(stdout, v); err != nil {
		return err
	}

	if verbose {
		bi, ok := debug.ReadBuildInfo()
		if ok {
			if _, err := fmt.Fprintf(stdout, "go version: %s\n", bi.GoVersion); err != nil {
				return err
			}
		}
	}

	return nil
}

func cliVersion() (string, bool) {
	bi, ok := debug.ReadBuildInfo()
	if !ok || bi.Main.Version == "" {
		return "", false
	}
	return bi.Main.Version, true
}

func global(wd string, args []string, stdout io.Writer) (string, []string, error) {
	var changeDir string
	flagSet := pflag.NewFlagSet("muxt global", pflag.ExitOnError)
	flagSet.SetOutput(stdout)
	flagSet.SetInterspersed(false)
	flagSet.StringVarP(&changeDir, "C", "C", "", "change root directory")
	if err := flagSet.Parse(args); err != nil {
		return "", nil, err
	}
	if filepath.IsAbs(changeDir) {
		return changeDir, flagSet.Args(), nil
	}
	cd, err := filepath.Abs(filepath.Join(wd, changeDir))
	if err != nil {
		return "", nil, err
	}
	return cd, flagSet.Args(), nil
}

const (
	// New flag names with clear prefixes/suffixes
	findTemplatesVariable        = "find-templates-variable"
	findReceiverType             = "find-receiver-type"
	findReceiverTypePackage      = "find-receiver-type-package"
	outputFile                   = "output-file"
	outputReceiverInterface      = "output-receiver-interface"
	outputRoutesFunc             = "output-routes-func"
	outputTemplateDataType       = "output-template-data-type"
	outputTemplateRoutePathsType = "output-template-route-paths-type"
	pathPrefixName               = "path-prefix"
	loggerName                   = "logger"

	// Deprecated flag names (for backward compatibility)
	deprecatedTemplatesVariable      = "templates-variable"
	deprecatedReceiverType           = "receiver-type"
	deprecatedReceiverTypePackage    = "receiver-type-package"
	deprecatedReceiverInterface      = "receiver-interface"
	deprecatedRoutesFunc             = "routes-func"
	deprecatedTemplateDataType       = "template-data-type"
	deprecatedTemplateRoutePathsType = "template-route-paths-type"

	// Help text
	findTemplatesVariableHelp   = `the name of the global variable with type *"html/template".Template in the working directory package.`
	findReceiverTypeHelp        = `The type name for a named type to use for looking up method signatures. If not set, all methods added to the receiver interface will have inferred signatures with argument types based on the argument identifier names. The inferred method signatures always return a single result of type any.`
	findReceiverTypePackageHelp = `The package path to use when looking for find-receiver-type. If not set, the package in the current directory is used.`

	outputFileHelp              = `The generated file name containing the routes function and receiver interface.`
	outputReceiverInterfaceHelp = `The interface name in the generated output file listing the methods used by the handler routes in the routes function.`
	outputRoutesFuncHelp        = `The function name for the package registering handler functions on an *"net/http".ServeMux.
This function also receives an argument with a type matching the name given by output-receiver-interface.`
	outputTemplateDataTypeHelp       = `The type name for the template data passed to root route templates.`
	outputTemplateRoutePathsTypeHelp = `The type name for the type with path constructor helper methods.`

	pathPrefixNameHelp = `Adds a path-prefix parameter to the TemplateRoutes function and use it in each path generator method.`
	loggerNameHelp     = `Adds a *slog.Logger parameter to the TemplateRoutes function and uses it to log ExecuteTemplate errors and debug information in handlers.`

	errIdentSuffix = " value must be a well-formed Go identifier"
)

func newRoutesFileConfiguration(args []string, stderr io.Writer) (muxt.RoutesFileConfiguration, error) {
	var g muxt.RoutesFileConfiguration
	flagSet := routesFileConfigurationFlagSet(&g)
	flagSet.SetOutput(stderr)
	if err := flagSet.Parse(args); err != nil {
		return g, err
	}
	if g.TemplatesVariable != "" && !token.IsIdentifier(g.TemplatesVariable) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(findTemplatesVariable + errIdentSuffix)
	}
	if g.RoutesFunction != "" && !token.IsIdentifier(g.RoutesFunction) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(outputRoutesFunc + errIdentSuffix)
	}
	if g.ReceiverType != "" && !token.IsIdentifier(g.ReceiverType) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(findReceiverType + errIdentSuffix)
	}
	if g.ReceiverInterface != "" && !token.IsIdentifier(g.ReceiverInterface) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(outputReceiverInterface + errIdentSuffix)
	}
	if g.TemplateDataType != "" && !token.IsIdentifier(g.TemplateDataType) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(outputTemplateDataType + errIdentSuffix)
	}
	if g.TemplateRoutePathsTypeName != "" && !token.IsIdentifier(g.TemplateRoutePathsTypeName) {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf(outputTemplateRoutePathsType + errIdentSuffix)
	}
	if g.OutputFileName != "" && filepath.Ext(g.OutputFileName) != ".go" {
		return muxt.RoutesFileConfiguration{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func routesFileConfigurationFlagSet(g *muxt.RoutesFileConfiguration) *pflag.FlagSet {
	flagSet := pflag.NewFlagSet("generate", pflag.ContinueOnError)

	// New flag names with clear prefixes/suffixes
	flagSet.StringVar(&g.TemplatesVariable, findTemplatesVariable, muxt.DefaultTemplatesVariableName, findTemplatesVariableHelp)
	flagSet.StringVar(&g.ReceiverType, findReceiverType, "", findReceiverTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, findReceiverTypePackage, "", findReceiverTypePackageHelp)

	flagSet.StringVar(&g.OutputFileName, outputFile, muxt.DefaultOutputFileName, outputFileHelp)
	flagSet.StringVar(&g.ReceiverInterface, outputReceiverInterface, muxt.DefaultReceiverInterfaceName, outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, outputRoutesFunc, muxt.DefaultRoutesFunctionName, outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, outputTemplateDataType, muxt.DefaultTemplateDataTypeName, outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, outputTemplateRoutePathsType, muxt.DefaultTemplateRoutePathsTypeName, outputTemplateRoutePathsTypeHelp)

	flagSet.BoolVar(&g.PathPrefix, pathPrefixName, false, pathPrefixNameHelp)
	flagSet.BoolVar(&g.Logger, loggerName, false, loggerNameHelp)
	flagSet.BoolVarP(&g.Verbose, "verbose", "v", false, "verbose log output")

	// Deprecated flags for backward compatibility
	flagSet.StringVar(&g.TemplatesVariable, deprecatedTemplatesVariable, muxt.DefaultTemplatesVariableName, "DEPRECATED: use --"+findTemplatesVariable+" instead. "+findTemplatesVariableHelp)
	flagSet.StringVar(&g.ReceiverType, deprecatedReceiverType, "", "DEPRECATED: use --"+findReceiverType+" instead. "+findReceiverTypeHelp)
	flagSet.StringVar(&g.ReceiverPackage, deprecatedReceiverTypePackage, "", "DEPRECATED: use --"+findReceiverTypePackage+" instead. "+findReceiverTypePackageHelp)
	flagSet.StringVar(&g.ReceiverInterface, deprecatedReceiverInterface, muxt.DefaultReceiverInterfaceName, "DEPRECATED: use --"+outputReceiverInterface+" instead. "+outputReceiverInterfaceHelp)
	flagSet.StringVar(&g.RoutesFunction, deprecatedRoutesFunc, muxt.DefaultRoutesFunctionName, "DEPRECATED: use --"+outputRoutesFunc+" instead. "+outputRoutesFuncHelp)
	flagSet.StringVar(&g.TemplateDataType, deprecatedTemplateDataType, muxt.DefaultTemplateDataTypeName, "DEPRECATED: use --"+outputTemplateDataType+" instead. "+outputTemplateDataTypeHelp)
	flagSet.StringVar(&g.TemplateRoutePathsTypeName, deprecatedTemplateRoutePathsType, muxt.DefaultTemplateRoutePathsTypeName, "DEPRECATED: use --"+outputTemplateRoutePathsType+" instead. "+outputTemplateRoutePathsTypeHelp)

	// Mark deprecated flags as deprecated
	if err := flagSet.MarkDeprecated(deprecatedTemplatesVariable, "use --"+findTemplatesVariable+" instead"); err != nil {
		panic(err)
	}
	if err := flagSet.MarkDeprecated(deprecatedReceiverType, "use --"+findReceiverType+" instead"); err != nil {
		panic(err)
	}
	if err := flagSet.MarkDeprecated(deprecatedReceiverTypePackage, "use --"+findReceiverTypePackage+" instead"); err != nil {
		panic(err)
	}
	if err := flagSet.MarkDeprecated(deprecatedReceiverInterface, "use --"+outputReceiverInterface+" instead"); err != nil {
		panic(err)
	}
	if err := flagSet.MarkDeprecated(deprecatedRoutesFunc, "use --"+outputRoutesFunc+" instead"); err != nil {
		panic(err)
	}
	if err := flagSet.MarkDeprecated(deprecatedTemplateDataType, "use --"+outputTemplateDataType+" instead"); err != nil {
		panic(err)
	}
	if err := flagSet.MarkDeprecated(deprecatedTemplateRoutePathsType, "use --"+outputTemplateRoutePathsType+" instead"); err != nil {
		panic(err)
	}

	return flagSet
}
