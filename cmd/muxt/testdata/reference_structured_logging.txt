# Tests structured logging with JSON parsing and type-safe field assertions

muxt generate --use-receiver-type=App --output-routes-func-with-logger-param

grep 'logger \*slog.Logger' template_routes.go

muxt check

exec go test -v

-- go.mod --
module example.com

go 1.24
-- app.go --
package main

import "context"

type App struct{}

func (*App) Hello(ctx context.Context) (string, error) {
	return "Hello", nil
}
-- template.go --
package main

import (
	"embed"
	"html/template"
)

//go:embed template.gohtml
var source embed.FS

var templates = template.Must(template.ParseFS(source, "template.gohtml"))

func init() {
	// Ensure templates is a package variable that can be replaced in tests
	_ = templates
}
-- template.gohtml --
{{define "GET / Hello(ctx)"}}
<!DOCTYPE html>
<html>
<body>
  <h1>{{.Result}}</h1>
</body>
</html>
{{end}}
-- main_test.go --
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"html/template"
	"log/slog"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

// LogEntry represents a structured slog JSON log entry
type LogEntry struct {
	Time    time.Time `json:"time"`
	Level   string    `json:"level"`
	Msg     string    `json:"msg"`
	Pattern string    `json:"pattern,omitempty"`
	Path    string    `json:"path,omitempty"`
	Method  string    `json:"method,omitempty"`
	Error   string    `json:"error,omitempty"`
}

func parseLogEntry(t *testing.T, logOutput string) LogEntry {
	t.Helper()
	var entry LogEntry
	if err := json.Unmarshal([]byte(logOutput), &entry); err != nil {
		t.Fatalf("failed to parse log entry: %v\nLog: %s", err, logOutput)
	}
	return entry
}

func TestStructuredLogging_DebugLevel(t *testing.T) {
	var logBuf bytes.Buffer
	logger := slog.New(slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{Level: slog.LevelDebug}))

	mux := http.NewServeMux()
	TemplateRoutes(mux, new(App), logger)

	rec := httptest.NewRecorder()
	req := httptest.NewRequest("GET", "/", nil)
	mux.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected 200, got %d", rec.Code)
	}

	// Parse structured log entry
	entry := parseLogEntry(t, logBuf.String())

	// Type-safe assertions on log fields
	if entry.Level != "DEBUG" {
		t.Errorf("expected Level='DEBUG', got %q", entry.Level)
	}

	if entry.Msg != "handling request" {
		t.Errorf("expected Msg='handling request', got %q", entry.Msg)
	}

	if entry.Pattern != "GET /" {
		t.Errorf("expected Pattern='GET /', got %q", entry.Pattern)
	}

	if entry.Path != "/" {
		t.Errorf("expected Path='/', got %q", entry.Path)
	}

	if entry.Method != "GET" {
		t.Errorf("expected Method='GET', got %q", entry.Method)
	}

	if entry.Time.IsZero() {
		t.Error("expected Time to be set")
	}
}

func TestStructuredLogging_ErrorLevel_TemplateFailure(t *testing.T) {
	var logBuf bytes.Buffer
	logger := slog.New(slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{Level: slog.LevelError}))

	mux := http.NewServeMux()
	// Use a broken template that will fail to execute
	brokenTemplates := template.Must(template.New("broken").Parse(`{{define "GET / Hello(ctx)"}}{{.InvalidField}}{{end}}`))
	oldTemplates := templates
	templates = brokenTemplates
	defer func() { templates = oldTemplates }()

	TemplateRoutes(mux, new(App), logger)

	rec := httptest.NewRecorder()
	req := httptest.NewRequest("GET", "/", nil)
	mux.ServeHTTP(rec, req)

	if rec.Code != http.StatusInternalServerError {
		t.Errorf("expected 500, got %d", rec.Code)
	}

	// Parse structured log entry
	entry := parseLogEntry(t, logBuf.String())

	// Type-safe assertions on error log fields
	if entry.Level != "ERROR" {
		t.Errorf("expected Level='ERROR', got %q", entry.Level)
	}

	if entry.Msg != "failed to render page" {
		t.Errorf("expected Msg='failed to render page', got %q", entry.Msg)
	}

	if entry.Pattern != "GET /" {
		t.Errorf("expected Pattern='GET /', got %q", entry.Pattern)
	}

	if entry.Path != "/" {
		t.Errorf("expected Path='/', got %q", entry.Path)
	}

	if entry.Error == "" {
		t.Error("expected Error field to be populated")
	}

	if entry.Time.IsZero() {
		t.Error("expected Time to be set")
	}
}

func TestStructuredLogging_InfoLevel_NoLogs(t *testing.T) {
	var logBuf bytes.Buffer
	logger := slog.New(slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{Level: slog.LevelInfo}))

	mux := http.NewServeMux()
	TemplateRoutes(mux, new(App), logger)

	rec := httptest.NewRecorder()
	req := httptest.NewRequest("GET", "/", nil)
	mux.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected 200, got %d", rec.Code)
	}

	// Successful requests should not log at INFO level
	if logBuf.Len() > 0 {
		t.Errorf("expected no logs at INFO level, got: %s", logBuf.String())
	}
}

func TestStructuredLogging_ReceiverError_NoErrorLog(t *testing.T) {
	var logBuf bytes.Buffer
	logger := slog.New(slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{Level: slog.LevelError}))

	failingApp := &FailingApp{err: errors.New("database error")}

	mux := http.NewServeMux()
	TemplateRoutes(mux, failingApp, logger)

	rec := httptest.NewRecorder()
	req := httptest.NewRequest("GET", "/", nil)
	mux.ServeHTTP(rec, req)

	if rec.Code != http.StatusInternalServerError {
		t.Errorf("expected 500, got %d", rec.Code)
	}

	// Receiver method errors are stored in TemplateData, not logged
	// This documents the design: templates handle receiver errors
	if logBuf.Len() > 0 {
		t.Logf("Unexpected log output for receiver error: %s", logBuf.String())
	}
}

// FailingApp is a test implementation that returns errors
type FailingApp struct {
	err error
}

func (a *FailingApp) Hello(ctx context.Context) (string, error) {
	return "", a.err
}
